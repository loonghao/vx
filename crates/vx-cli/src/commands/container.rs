//! Container command handlers
//!
//! Handles container-related commands:
//! - Dockerfile generation
//! - Image building
//! - Registry push
//! - Container status

use crate::ui::UI;
use std::env;
use std::path::Path;
use std::process::Command;
use vx_config::{
    parse_config, ContainerManager, DockerfileGenerator, GitInfo, GoDockerConfig,
    NodejsDockerConfig, PythonDockerConfig, RustDockerConfig,
};

/// Handle `vx container generate` command
pub async fn handle_generate(
    output: Option<String>,
    with_ignore: bool,
    dry_run: bool,
    template: Option<String>,
) -> anyhow::Result<()> {
    let current_dir = env::current_dir()?;
    let config_path = current_dir.join(".vx.toml");

    // Check if using ecosystem template
    if let Some(tpl) = &template {
        let dockerfile_content = match tpl.as_str() {
            "node" | "nodejs" => {
                UI::info("Generating Node.js Dockerfile...");
                DockerfileGenerator::nodejs(&NodejsDockerConfig::default())
            }
            "python" | "py" => {
                UI::info("Generating Python Dockerfile...");
                DockerfileGenerator::python(&PythonDockerConfig::default())
            }
            "rust" | "rs" => {
                UI::info("Generating Rust Dockerfile...");
                DockerfileGenerator::rust(&RustDockerConfig::default())
            }
            "go" | "golang" => {
                UI::info("Generating Go Dockerfile...");
                DockerfileGenerator::go(&GoDockerConfig::default())
            }
            _ => {
                return Err(anyhow::anyhow!(
                    "Unknown template '{}'. Available: node, python, rust, go",
                    tpl
                ));
            }
        };

        if dry_run {
            UI::info("Preview (dry-run mode):");
            println!("{}", dockerfile_content);
            return Ok(());
        }

        let output_path = output.unwrap_or_else(|| "Dockerfile".to_string());
        std::fs::write(&output_path, dockerfile_content)?;
        UI::success(&format!("Generated {}", output_path));

        if with_ignore {
            generate_default_dockerignore(&current_dir)?;
        }

        return Ok(());
    }

    // Use configuration from .vx.toml
    if !config_path.exists() {
        return Err(anyhow::anyhow!(
            "No .vx.toml found. Use --template to generate without config, or run 'vx init' first."
        ));
    }

    let config_content = std::fs::read_to_string(&config_path)?;
    let config = parse_config(&config_content)?;

    let manager = ContainerManager::from_vx_config(&config).ok_or_else(|| {
        anyhow::anyhow!("No [container] section found in .vx.toml. Add container configuration or use --template.")
    })?;

    if !manager.is_enabled() {
        return Err(anyhow::anyhow!(
            "Container support is disabled. Set container.enabled = true in .vx.toml"
        ));
    }

    let dockerfile_content = manager.generate_dockerfile()?;

    if dry_run {
        UI::info("Preview (dry-run mode):");
        println!("{}", dockerfile_content);
        return Ok(());
    }

    // Write Dockerfile
    let output_path = output.unwrap_or_else(|| "Dockerfile".to_string());
    std::fs::write(&output_path, &dockerfile_content)?;
    UI::success(&format!("Generated {}", output_path));

    // Optionally generate .dockerignore
    if with_ignore {
        let ignore_content = manager.generate_dockerignore();
        std::fs::write(".dockerignore", ignore_content)?;
        UI::success("Generated .dockerignore");
    }

    Ok(())
}

/// Generate default .dockerignore
fn generate_default_dockerignore(project_root: &Path) -> anyhow::Result<()> {
    let content = r#"# Generated by vx

# Git
.git
.gitignore

# IDE
.idea
.vscode
*.swp
*.swo

# Build artifacts
target/
dist/
build/
node_modules/
__pycache__/
*.pyc

# Docker
Dockerfile*
docker-compose*.yml
.dockerignore

# Documentation
*.md
docs/

# Tests
tests/
test/
*_test.go
*_test.rs
"#;

    std::fs::write(project_root.join(".dockerignore"), content)?;
    UI::success("Generated .dockerignore");
    Ok(())
}

/// Handle `vx container build` command
pub async fn handle_build(
    tags: Vec<String>,
    target: Option<String>,
    build_args: Vec<String>,
    platforms: Vec<String>,
    no_cache: bool,
    push: bool,
    verbose: bool,
) -> anyhow::Result<()> {
    let current_dir = env::current_dir()?;
    let config_path = current_dir.join(".vx.toml");

    // Determine runtime and image tags
    let (runtime, image_tags) = if config_path.exists() {
        let config_content = std::fs::read_to_string(&config_path)?;
        let config = parse_config(&config_content)?;

        if let Some(manager) = ContainerManager::from_vx_config(&config) {
            let git_info = GitInfo::from_current_dir();
            let mut generated_tags = manager.generate_tags(&git_info);

            // Add user-provided tags
            for tag in &tags {
                if !generated_tags.contains(tag) {
                    generated_tags.push(tag.clone());
                }
            }

            (manager.runtime().to_string(), generated_tags)
        } else {
            ("docker".to_string(), tags)
        }
    } else {
        ("docker".to_string(), tags)
    };

    if image_tags.is_empty() {
        return Err(anyhow::anyhow!(
            "No image tags specified. Use -t/--tag or configure in .vx.toml"
        ));
    }

    // Build command
    let mut cmd = Command::new(&runtime);
    cmd.arg("build");

    // Add tags
    for tag in &image_tags {
        cmd.arg("-t").arg(tag);
    }

    // Add target
    if let Some(t) = &target {
        cmd.arg("--target").arg(t);
    }

    // Add build args
    for arg in &build_args {
        cmd.arg("--build-arg").arg(arg);
    }

    // Add platforms
    if !platforms.is_empty() {
        cmd.arg("--platform").arg(platforms.join(","));
    }

    // No cache
    if no_cache {
        cmd.arg("--no-cache");
    }

    // Context
    cmd.arg(".");

    UI::info(&format!("Building container image with {}...", runtime));
    if verbose {
        UI::info(&format!("Tags: {}", image_tags.join(", ")));
    }

    let status = cmd.status()?;

    if !status.success() {
        return Err(anyhow::anyhow!("Container build failed"));
    }

    UI::success("Container image built successfully");

    // Push if requested
    if push {
        for tag in &image_tags {
            UI::info(&format!("Pushing {}...", tag));
            let push_status = Command::new(&runtime).arg("push").arg(tag).status()?;

            if !push_status.success() {
                UI::warning(&format!("Failed to push {}", tag));
            } else {
                UI::success(&format!("Pushed {}", tag));
            }
        }
    }

    Ok(())
}

/// Handle `vx container push` command
pub async fn handle_push(tag: Option<String>, verbose: bool) -> anyhow::Result<()> {
    let current_dir = env::current_dir()?;
    let config_path = current_dir.join(".vx.toml");

    let (runtime, tags_to_push) = if let Some(t) = tag {
        ("docker".to_string(), vec![t])
    } else if config_path.exists() {
        let config_content = std::fs::read_to_string(&config_path)?;
        let config = parse_config(&config_content)?;

        if let Some(manager) = ContainerManager::from_vx_config(&config) {
            let git_info = GitInfo::from_current_dir();
            (
                manager.runtime().to_string(),
                manager.generate_tags(&git_info),
            )
        } else {
            return Err(anyhow::anyhow!(
                "No container configuration found. Specify a tag or configure in .vx.toml"
            ));
        }
    } else {
        return Err(anyhow::anyhow!("No tag specified and no .vx.toml found"));
    };

    if tags_to_push.is_empty() {
        return Err(anyhow::anyhow!("No tags to push"));
    }

    for tag in &tags_to_push {
        UI::info(&format!("Pushing {}...", tag));
        if verbose {
            UI::info(&format!("Using runtime: {}", runtime));
        }

        let status = Command::new(&runtime).arg("push").arg(tag).status()?;

        if !status.success() {
            UI::error(&format!("Failed to push {}", tag));
        } else {
            UI::success(&format!("Pushed {}", tag));
        }
    }

    Ok(())
}

/// Handle `vx container status` command
pub async fn handle_status() -> anyhow::Result<()> {
    let current_dir = env::current_dir()?;
    let config_path = current_dir.join(".vx.toml");

    // Check container runtime availability
    let docker_available = Command::new("docker")
        .arg("--version")
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false);

    let podman_available = Command::new("podman")
        .arg("--version")
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false);

    println!("Container Status");
    println!("================");
    println!();

    println!("Runtimes:");
    println!(
        "  Docker: {}",
        if docker_available {
            "✓ available"
        } else {
            "✗ not found"
        }
    );
    println!(
        "  Podman: {}",
        if podman_available {
            "✓ available"
        } else {
            "✗ not found"
        }
    );
    println!();

    // Check configuration
    if config_path.exists() {
        let config_content = std::fs::read_to_string(&config_path)?;
        let config = parse_config(&config_content)?;

        if let Some(container) = &config.container {
            println!("Configuration (.vx.toml):");
            println!(
                "  Enabled: {}",
                if container.enabled.unwrap_or(false) {
                    "✓ yes"
                } else {
                    "✗ no"
                }
            );
            println!(
                "  Runtime: {}",
                container.runtime.as_deref().unwrap_or("docker (default)")
            );

            if let Some(registry) = &container.registry {
                println!(
                    "  Registry: {}",
                    registry.url.as_deref().unwrap_or("docker.io")
                );
                println!(
                    "  Image: {}",
                    registry.image.as_deref().unwrap_or("(not set)")
                );
            }

            if let Some(dockerfile) = &container.dockerfile {
                println!(
                    "  Dockerfile: {}",
                    dockerfile.output.as_deref().unwrap_or("Dockerfile")
                );
                println!(
                    "  Base image: {}",
                    dockerfile.base_image.as_deref().unwrap_or("(not set)")
                );
            }

            // Show generated tags
            if let Some(manager) = ContainerManager::from_vx_config(&config) {
                let git_info = GitInfo::from_current_dir();
                let tags = manager.generate_tags(&git_info);
                if !tags.is_empty() {
                    println!();
                    println!("Generated tags:");
                    for tag in tags {
                        println!("  - {}", tag);
                    }
                }
            }
        } else {
            println!("Configuration: No [container] section in .vx.toml");
        }
    } else {
        println!("Configuration: No .vx.toml found");
    }

    // Check for existing Dockerfile
    println!();
    println!("Files:");
    let dockerfile_exists = current_dir.join("Dockerfile").exists();
    let dockerignore_exists = current_dir.join(".dockerignore").exists();
    println!(
        "  Dockerfile: {}",
        if dockerfile_exists {
            "✓ exists"
        } else {
            "✗ not found"
        }
    );
    println!(
        "  .dockerignore: {}",
        if dockerignore_exists {
            "✓ exists"
        } else {
            "✗ not found"
        }
    );

    Ok(())
}

/// Handle `vx container login` command
pub async fn handle_login(
    registry: Option<String>,
    username: Option<String>,
    password: Option<String>,
) -> anyhow::Result<()> {
    let current_dir = env::current_dir()?;
    let config_path = current_dir.join(".vx.toml");

    // Determine runtime and registry
    let (runtime, registry_url) = if config_path.exists() {
        let config_content = std::fs::read_to_string(&config_path)?;
        let config = parse_config(&config_content)?;

        if let Some(manager) = ContainerManager::from_vx_config(&config) {
            let url = registry.or_else(|| {
                config
                    .container
                    .as_ref()
                    .and_then(|c| c.registry.as_ref())
                    .and_then(|r| r.url.clone())
            });
            (manager.runtime().to_string(), url)
        } else {
            ("docker".to_string(), registry)
        }
    } else {
        ("docker".to_string(), registry)
    };

    let mut cmd = Command::new(&runtime);
    cmd.arg("login");

    if let Some(u) = &username {
        cmd.arg("-u").arg(u);
    }

    if let Some(p) = &password {
        cmd.arg("-p").arg(p);
    }

    if let Some(r) = &registry_url {
        cmd.arg(r);
    }

    UI::info(&format!(
        "Logging in to {}...",
        registry_url.as_deref().unwrap_or("Docker Hub")
    ));

    let status = cmd.status()?;

    if status.success() {
        UI::success("Login successful");
    } else {
        return Err(anyhow::anyhow!("Login failed"));
    }

    Ok(())
}

/// Handle `vx container tags` command
pub async fn handle_tags(all: bool) -> anyhow::Result<()> {
    let current_dir = env::current_dir()?;
    let config_path = current_dir.join(".vx.toml");

    if !config_path.exists() {
        return Err(anyhow::anyhow!("No .vx.toml found"));
    }

    let config_content = std::fs::read_to_string(&config_path)?;
    let config = parse_config(&config_content)?;

    let manager = ContainerManager::from_vx_config(&config)
        .ok_or_else(|| anyhow::anyhow!("No [container] section found in .vx.toml"))?;

    let git_info = GitInfo::from_current_dir();
    let tags = manager.generate_tags(&git_info);

    if tags.is_empty() {
        UI::warning("No tags configured");
        return Ok(());
    }

    println!("Image Tags");
    println!("==========");

    if all {
        println!();
        println!("Git Info:");
        println!("  SHA: {}", git_info.sha.as_deref().unwrap_or("(unknown)"));
        println!(
            "  Branch: {}",
            git_info.branch.as_deref().unwrap_or("(unknown)")
        );
        println!("  Tag: {}", git_info.tag.as_deref().unwrap_or("(none)"));
        println!();
    }

    println!("Generated Tags:");
    for tag in tags {
        println!("  {}", tag);
    }

    Ok(())
}

//! Build script for vx-cli
//!
//! This script:
//! 1. Collects all `provider.toml` manifests at compile time and embeds them
//!    into the binary (RFC 0013: Manifest-Driven Provider Registration)
//! 2. On Windows, locates and embeds bridge binaries (e.g., `MSBuild.exe`)
//!    so they can be deployed without shipping separate files

use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    embed_provider_manifests();
    embed_bridge_binaries();
}

fn embed_provider_manifests() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("provider_manifests.rs");
    // The combined TOML file that will be embedded via include_str!
    let combined_toml_path = Path::new(&out_dir).join("all_providers.toml");

    // Find the vx-providers directory relative to this crate
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let providers_dir = Path::new(&manifest_dir).join("../vx-providers");

    let mut manifests: Vec<(String, String)> = Vec::new();

    if providers_dir.exists()
        && let Ok(entries) = fs::read_dir(&providers_dir)
    {
        for entry in entries.flatten() {
            let provider_dir = entry.path();
            if !provider_dir.is_dir() {
                continue;
            }

            let dir_name = provider_dir
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("unknown")
                .to_string();

            // Load provider.star: extract metadata and generate minimal TOML
            let star_path = provider_dir.join("provider.star");
            if star_path.exists()
                && let Ok(content) = fs::read_to_string(&star_path)
                && let Some(toml) = extract_manifest_from_star(&dir_name, &content)
            {
                manifests.push((dir_name, toml));
            }
        }
    }

    // Sort manifests by name for deterministic output
    manifests.sort_by(|a, b| a.0.cmp(&b.0));

    // -------------------------------------------------------------------------
    // Write the combined TOML file
    //
    // Format: each provider is separated by a TOML comment line:
    //   # ===PROVIDER:<name>===
    // TOML comments are ignored by the TOML parser, so this delimiter is safe.
    // -------------------------------------------------------------------------
    let mut combined = String::new();
    combined.push_str("# Auto-generated combined provider manifests\n");
    combined.push_str("# Generated by build.rs at compile time - DO NOT EDIT\n\n");

    for (name, content) in &manifests {
        combined.push_str(&format!("# ===PROVIDER:{}===\n", name));
        combined.push_str(content.trim());
        combined.push_str("\n\n");
    }

    fs::write(&combined_toml_path, &combined).unwrap();

    // -------------------------------------------------------------------------
    // Generate the Rust glue code — minimal: just the include_str! path and
    // the provider count.  All parsing logic lives in registry.rs directly,
    // so there is nothing to "generate" here.
    // -------------------------------------------------------------------------
    let combined_toml_path_escaped = combined_toml_path
        .display()
        .to_string()
        .replace('\\', "\\\\");

    let count = manifests.len();

    // Keep the generated file small and readable — no generated functions.
    let code = format!(
        concat!(
            "// Auto-generated by build.rs — DO NOT EDIT\n",
            "pub(crate) static ALL_PROVIDERS_TOML: &str = include_str!(\"{path}\");\n",
            "pub(crate) const PROVIDER_COUNT: usize = {count};\n",
        ),
        path = combined_toml_path_escaped,
        count = count,
    );

    fs::write(&dest_path, code).unwrap();
    // Tell Cargo to rerun this script if any provider file changes
    if providers_dir.exists() {
        println!("cargo:rerun-if-changed={}", providers_dir.display());
        if let Ok(entries) = fs::read_dir(&providers_dir) {
            for entry in entries.flatten() {
                let dir = entry.path();
                let star_path = dir.join("provider.star");
                if star_path.exists() {
                    println!("cargo:rerun-if-changed={}", star_path.display());
                }
            }
        }
    }

    // -------------------------------------------------------------------------
    // Generate provider_stars.rs — embeds all provider.star files so that
    // ProviderHandle can be registered at startup without filesystem access.
    //
    // Format: a static array of (name, star_content) pairs.
    // -------------------------------------------------------------------------
    embed_provider_stars(&out_dir, &providers_dir);
}

fn embed_provider_stars(out_dir: &str, providers_dir: &Path) {
    let dest_path = Path::new(out_dir).join("provider_stars.rs");

    let mut entries: Vec<(String, PathBuf)> = Vec::new();

    if providers_dir.exists()
        && let Ok(dir_entries) = fs::read_dir(providers_dir)
    {
        for entry in dir_entries.flatten() {
            let provider_dir = entry.path();
            if !provider_dir.is_dir() {
                continue;
            }
            let star_path = provider_dir.join("provider.star");
            if star_path.exists() {
                let dir_name = provider_dir
                    .file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("unknown")
                    .to_string();
                entries.push((dir_name, star_path));
            }
        }
    }

    // Sort for deterministic output
    entries.sort_by(|a, b| a.0.cmp(&b.0));

    let mut code = String::new();
    code.push_str("// Auto-generated by build.rs — DO NOT EDIT\n");
    code.push_str("// Embedded provider.star contents for ProviderHandle registration\n\n");

    // Generate individual constants
    for (name, star_path) in &entries {
        let const_name = name.to_uppercase().replace('-', "_");
        let path_escaped = star_path.display().to_string().replace('\\', "\\\\");
        code.push_str(&format!(
            "pub(crate) static PROVIDER_STAR_{}: &str = include_str!(\"{}\");\n",
            const_name, path_escaped
        ));
    }

    code.push('\n');

    // Generate the combined array
    code.push_str("/// All embedded provider.star contents: `(provider_name, star_content)`\n");
    code.push_str("pub(crate) static ALL_PROVIDER_STARS: &[(&str, &str)] = &[\n");
    for (name, _) in &entries {
        let const_name = name.to_uppercase().replace('-', "_");
        code.push_str(&format!(
            "    (\"{}\", PROVIDER_STAR_{}),\n",
            name, const_name
        ));
    }
    code.push_str("];\n");

    fs::write(&dest_path, code).unwrap();
}

/// Extract provider metadata from a Starlark provider.star file and generate
/// a minimal TOML manifest compatible with ProviderManifest::parse().
///
/// Parses the following patterns from the Starlark script:
/// - `def name(): return "xxx"` → provider name
/// - `def description(): return "xxx"` → provider description
/// - `def ecosystem(): return "xxx"` → provider ecosystem
/// - `def homepage(): return "xxx"` → provider homepage
/// - `runtimes = [{"name": "xxx", "executable": "xxx", ...}]` → runtime defs
/// - `platforms = {"os": [...]}` → platform constraints
fn extract_manifest_from_star(dir_name: &str, content: &str) -> Option<String> {
    // Extract name from `def name(): return "xxx"` or use dir_name as fallback
    let provider_name =
        extract_star_string_fn(content, "name").unwrap_or_else(|| dir_name.to_string());

    // Extract optional fields
    let description = extract_star_string_fn(content, "description").unwrap_or_default();
    let ecosystem = extract_star_string_fn(content, "ecosystem").unwrap_or_default();
    let homepage = extract_star_string_fn(content, "homepage");

    // Extract runtimes from `runtimes = [...]` block
    let runtimes = extract_star_runtimes(content);

    // Extract platform constraints from `platforms = {...}` or provider-level `platform_constraint`
    let platform_os = extract_star_platform_os(content);

    // Build minimal TOML
    let mut toml = String::new();
    toml.push_str("[provider]\n");
    toml.push_str(&format!(
        "name = \"{}\"\n",
        escape_toml_string(&provider_name)
    ));
    if !description.is_empty() {
        toml.push_str(&format!(
            "description = \"{}\"\n",
            escape_toml_string(&description)
        ));
    }
    if !ecosystem.is_empty() {
        toml.push_str(&format!(
            "ecosystem = \"{}\"\n",
            escape_toml_string(&ecosystem)
        ));
    }
    if let Some(ref hp) = homepage {
        toml.push_str(&format!("homepage = \"{}\"\n", escape_toml_string(hp)));
    }

    // Platform constraints at provider level
    if let Some(ref os_list) = platform_os {
        toml.push_str("\n[provider.platforms]\n");
        let os_values: Vec<String> = os_list.iter().map(|s| format!("\"{}\"", s)).collect();
        toml.push_str(&format!("os = [{}]\n", os_values.join(", ")));
    }

    // Runtime definitions
    if runtimes.is_empty() {
        // Fallback: create a single runtime with the provider name
        toml.push_str("\n[[runtimes]]\n");
        toml.push_str(&format!(
            "name = \"{}\"\n",
            escape_toml_string(&provider_name)
        ));
        toml.push_str(&format!(
            "executable = \"{}\"\n",
            escape_toml_string(&provider_name)
        ));
    } else {
        for rt in &runtimes {
            toml.push_str("\n[[runtimes]]\n");
            toml.push_str(&format!("name = \"{}\"\n", escape_toml_string(&rt.name)));
            toml.push_str(&format!(
                "executable = \"{}\"\n",
                escape_toml_string(&rt.executable)
            ));
            if !rt.description.is_empty() {
                toml.push_str(&format!(
                    "description = \"{}\"\n",
                    escape_toml_string(&rt.description)
                ));
            }
            if !rt.aliases.is_empty() {
                let alias_values: Vec<String> =
                    rt.aliases.iter().map(|s| format!("\"{}\"", s)).collect();
                toml.push_str(&format!("aliases = [{}]\n", alias_values.join(", ")));
            }
            if rt.priority != 100 {
                toml.push_str(&format!("priority = {}\n", rt.priority));
            }
        }
    }

    Some(toml)
}

/// Escape a string for use in TOML double-quoted strings
fn escape_toml_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

/// Extract the return value of a simple single-line Starlark function:
///   def <fn_name>():
///       return "value"
fn extract_star_string_fn(content: &str, fn_name: &str) -> Option<String> {
    let def_pattern = format!("def {}():", fn_name);
    let lines: Vec<&str> = content.lines().collect();

    for (i, line) in lines.iter().enumerate() {
        let trimmed = line.trim();
        if trimmed == def_pattern || trimmed.starts_with(&def_pattern) {
            // Look at the next few lines for `return "value"`
            for (j, next_line) in lines.iter().enumerate().skip(i + 1).take(4) {
                let next = next_line.trim();
                let _ = j;
                if next.starts_with("return \"") || next.starts_with("return '") {
                    return extract_quoted_string(next.trim_start_matches("return").trim());
                }
                // Skip blank lines and comments
                if !next.is_empty() && !next.starts_with('#') {
                    break;
                }
            }
        }
    }
    None
}

/// Extract a quoted string value: "foo" or 'foo'
fn extract_quoted_string(s: &str) -> Option<String> {
    let s = s.trim();
    if s.starts_with('"') && s.contains('"') {
        let inner = s.trim_start_matches('"');
        let end = inner.find('"')?;
        return Some(inner[..end].to_string());
    }
    if s.starts_with('\'') && s.contains('\'') {
        let inner = s.trim_start_matches('\'');
        let end = inner.find('\'')?;
        return Some(inner[..end].to_string());
    }
    None
}

/// Minimal runtime info extracted from a Starlark runtimes list
struct StarRuntime {
    name: String,
    executable: String,
    description: String,
    aliases: Vec<String>,
    priority: u32,
}

/// Extract runtime definitions from `runtimes = [...]` in a Starlark script.
///
/// Handles the common pattern:
/// ```python
/// runtimes = [
///     {
///         "name":        "foo",
///         "executable":  "foo",
///         "description": "...",
///         "aliases":     ["bar"],
///         "priority":    100,
///     },
/// ]
/// ```
fn extract_star_runtimes(content: &str) -> Vec<StarRuntime> {
    let mut runtimes = Vec::new();

    // Find `runtimes = [` line
    let lines: Vec<&str> = content.lines().collect();
    let mut i = 0;
    while i < lines.len() {
        let trimmed = lines[i].trim();
        if trimmed == "runtimes = [" || trimmed.starts_with("runtimes = [") {
            // Collect lines until the closing `]` at the same indent level
            let mut depth = 0;
            let mut block = String::new();
            let start_indent = lines[i].len() - lines[i].trim_start().len();

            for (j, line) in lines.iter().enumerate().skip(i) {
                block.push_str(line);
                block.push('\n');

                for ch in line.chars() {
                    match ch {
                        '[' | '{' => depth += 1,
                        ']' | '}' => depth -= 1,
                        _ => {}
                    }
                }

                if j > i && depth <= 0 {
                    break;
                }
                let _ = start_indent;
            }

            // Parse individual runtime dicts from the block
            runtimes = parse_star_runtime_dicts(&block);
            break;
        }
        i += 1;
    }

    runtimes
}

/// Parse runtime dicts from a Starlark list block string
fn parse_star_runtime_dicts(block: &str) -> Vec<StarRuntime> {
    let mut runtimes = Vec::new();

    // Split by `{` to find individual dicts
    let mut depth = 0i32;
    let mut dict_start = None;
    let chars: Vec<char> = block.chars().collect();

    for (i, &ch) in chars.iter().enumerate() {
        match ch {
            '{' => {
                depth += 1;
                if depth == 1 {
                    dict_start = Some(i);
                }
            }
            '}' => {
                depth -= 1;
                if depth == 0
                    && let Some(start) = dict_start
                {
                    let dict_str: String = chars[start..=i].iter().collect();
                    if let Some(rt) = parse_single_runtime_dict(&dict_str) {
                        runtimes.push(rt);
                    }
                    dict_start = None;
                }
            }
            _ => {}
        }
    }

    runtimes
}

/// Parse a single runtime dict string like `{"name": "foo", "executable": "foo", ...}`
fn parse_single_runtime_dict(dict: &str) -> Option<StarRuntime> {
    let name = extract_dict_string_value(dict, "name")?;
    let executable = extract_dict_string_value(dict, "executable").unwrap_or_else(|| name.clone());
    let description = extract_dict_string_value(dict, "description").unwrap_or_default();
    let aliases = extract_dict_string_list(dict, "aliases");
    let priority = extract_dict_int_value(dict, "priority").unwrap_or(100);

    Some(StarRuntime {
        name,
        executable,
        description,
        aliases,
        priority,
    })
}

/// Extract a string value from a dict-like string: `"key": "value"`
fn extract_dict_string_value(dict: &str, key: &str) -> Option<String> {
    // Look for `"key": "value"` or `"key":  "value"`
    let pattern = format!("\"{}\"", key);
    let pos = dict.find(&pattern)?;
    let after_key = &dict[pos + pattern.len()..];
    // Skip whitespace and colon
    let after_colon = after_key.trim_start().trim_start_matches(':').trim_start();
    extract_quoted_string(after_colon)
}

/// Extract an integer value from a dict-like string: `"key": 123`
fn extract_dict_int_value(dict: &str, key: &str) -> Option<u32> {
    let pattern = format!("\"{}\"", key);
    let pos = dict.find(&pattern)?;
    let after_key = &dict[pos + pattern.len()..];
    let after_colon = after_key.trim_start().trim_start_matches(':').trim_start();
    // Read digits
    let digits: String = after_colon
        .chars()
        .take_while(|c| c.is_ascii_digit())
        .collect();
    digits.parse().ok()
}

/// Extract a string list from a dict-like string: `"key": ["a", "b"]`
fn extract_dict_string_list(dict: &str, key: &str) -> Vec<String> {
    let pattern = format!("\"{}\"", key);
    let pos = match dict.find(&pattern) {
        Some(p) => p,
        None => return vec![],
    };
    let after_key = &dict[pos + pattern.len()..];
    let after_colon = after_key.trim_start().trim_start_matches(':').trim_start();

    // Find the `[...]` block
    if !after_colon.starts_with('[') {
        return vec![];
    }
    let end = after_colon.find(']').unwrap_or(after_colon.len());
    let list_str = &after_colon[1..end];

    // Extract quoted strings from the list
    let mut result = Vec::new();
    let mut remaining = list_str;
    while let Some(s) = extract_quoted_string(remaining.trim_start()) {
        result.push(s.clone());
        // Advance past this string
        let skip = remaining
            .find(&format!("\"{}\"", s))
            .or_else(|| remaining.find(&format!("'{}'", s)))
            .unwrap_or(0);
        remaining = &remaining[skip + s.len() + 2..];
        // Skip comma
        remaining = remaining.trim_start().trim_start_matches(',');
    }
    result
}

/// Extract platform OS list from a Starlark provider file.
///
/// Handles three patterns:
///
/// 1. `platforms = {"os": ["windows"]}` (single-line dict)
/// 2. Multi-line `platforms = {` block
/// 3. `def supported_platforms(): return [{"os": "windows", ...}, ...]`
fn extract_star_platform_os(content: &str) -> Option<Vec<String>> {
    // Pattern 1 & 2: `platforms = {` variable
    let lines: Vec<&str> = content.lines().collect();
    for (i, line) in lines.iter().enumerate() {
        let trimmed = line.trim();
        if trimmed.starts_with("platforms") && trimmed.contains('{') {
            if trimmed.contains('"') || trimmed.contains('\'') {
                // Single-line: platforms = {"os": ["windows"]}
                let os_list = extract_dict_string_list(trimmed, "os");
                if !os_list.is_empty() {
                    return Some(os_list);
                }
            }
            // Multi-line block
            let mut block = String::new();
            let mut depth = 0i32;
            for (j, line) in lines.iter().enumerate().skip(i) {
                block.push_str(line);
                block.push('\n');
                for ch in line.chars() {
                    match ch {
                        '{' => depth += 1,
                        '}' => depth -= 1,
                        _ => {}
                    }
                }
                if j > i && depth <= 0 {
                    break;
                }
            }
            let os_list = extract_dict_string_list(&block, "os");
            if !os_list.is_empty() {
                return Some(os_list);
            }
        }
    }

    // Pattern 3: `def supported_platforms():` returning a list of dicts
    // e.g. [{"os": "windows", "arch": "x64"}, {"os": "windows", "arch": "arm64"}]
    // We collect all unique "os" values from the returned list.
    if let Some(fn_start) = content.find("def supported_platforms():") {
        // Collect the function body (lines until dedent)
        let body_start = content[fn_start..]
            .find('\n')
            .map(|p| fn_start + p + 1)
            .unwrap_or(fn_start);
        let body = &content[body_start..];

        // Find the return statement and its list
        for line in body.lines() {
            let t = line.trim();
            if t.starts_with("return [") || t.starts_with("return[") {
                // Collect until the closing `]`
                let list_start =
                    fn_start + content[fn_start..].find(t).unwrap_or(0) + t.find('[').unwrap_or(0);
                let list_str = &content[list_start..];
                let end = list_str.find(']').unwrap_or(list_str.len());
                let inner = &list_str[1..end];

                // Extract all "os" values from the dicts in the list
                let mut os_values: Vec<String> = Vec::new();
                let mut remaining = inner;
                while let Some(os_val) = extract_dict_string_value(remaining, "os") {
                    if !os_values.contains(&os_val) {
                        os_values.push(os_val.clone());
                    }
                    // Advance past this occurrence
                    let skip = remaining.find("\"os\"").unwrap_or(remaining.len());
                    remaining = &remaining[skip + 4..];
                }
                if !os_values.is_empty() {
                    return Some(os_values);
                }
                break;
            }
            // Stop at first non-empty, non-comment, non-indented line (dedent)
            if !t.is_empty()
                && !t.starts_with('#')
                && !line.starts_with(' ')
                && !line.starts_with('\t')
            {
                break;
            }
        }
    }

    None
}

/// Embed bridge binaries (Windows only).
///
/// On Windows, we embed `MSBuild.exe` (from `vx-msbuild-bridge`) directly into
/// the `vx` binary. This is done by searching the cargo target directory for the
/// compiled bridge binary and generating `include_bytes!` code.
///
/// For non-Windows targets, an empty byte slice is embedded instead.
fn embed_bridge_binaries() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("embedded_bridges.rs");

    let mut code = String::new();
    code.push_str("// Auto-generated embedded bridge binaries\n");
    code.push_str("// Generated by build.rs at compile time\n\n");

    // Only embed on Windows targets
    let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();
    if target_os == "windows" {
        if let Some(bridge_path) = find_msbuild_bridge() {
            // Use include_bytes! to embed the bridge binary
            let bridge_path_escaped = bridge_path.display().to_string().replace('\\', "\\\\");
            code.push_str(&format!(
                "/// Embedded MSBuild bridge binary (compiled from vx-msbuild-bridge)\n\
                 pub static MSBUILD_BRIDGE_BYTES: &[u8] = include_bytes!(\"{}\");\n",
                bridge_path_escaped
            ));
            println!("cargo:rerun-if-changed={}", bridge_path.display());
            eprintln!(
                "cargo:warning=Embedding MSBuild bridge from: {}",
                bridge_path.display()
            );
        } else {
            code.push_str(
                "/// MSBuild bridge binary not found at build time — will use filesystem fallback\n\
                 pub static MSBUILD_BRIDGE_BYTES: &[u8] = &[];\n",
            );
            eprintln!(
                "cargo:warning=MSBuild bridge binary not found, embedding empty placeholder. Build vx-msbuild-bridge first: cargo build -p vx-msbuild-bridge"
            );
        }
    } else {
        code.push_str(
            "/// MSBuild bridge is Windows-only\n\
             pub static MSBUILD_BRIDGE_BYTES: &[u8] = &[];\n",
        );
    }

    fs::write(&dest_path, code).unwrap();
}

/// Search for the compiled MSBuild bridge binary in the target directory.
///
/// We search both release and debug profiles, preferring the same profile
/// as the current build.
fn find_msbuild_bridge() -> Option<PathBuf> {
    let out_dir = env::var("OUT_DIR").ok()?;

    // OUT_DIR is something like: target/<profile>/build/vx-cli-<hash>/out
    // We need to navigate up to the target/<profile> directory
    let out_path = PathBuf::from(&out_dir);

    // Walk up to find the target directory
    // OUT_DIR = <target_dir>/<profile>/build/<crate>-<hash>/out
    let target_profile_dir = out_path.parent()?.parent()?.parent()?;
    let target_dir = target_profile_dir.parent()?;

    let bridge_name = "MSBuild.exe";

    // Try current profile first
    let current_profile_candidate = target_profile_dir.join(bridge_name);
    if current_profile_candidate.exists() {
        return Some(current_profile_candidate);
    }

    // Try release profile
    let release_candidate = target_dir.join("release").join(bridge_name);
    if release_candidate.exists() {
        return Some(release_candidate);
    }

    // Try debug profile
    let debug_candidate = target_dir.join("debug").join(bridge_name);
    if debug_candidate.exists() {
        return Some(debug_candidate);
    }

    None
}

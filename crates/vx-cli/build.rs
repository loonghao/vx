//! Build script for vx-cli
//!
//! This script:
//! 1. Collects all `provider.toml` manifests at compile time and embeds them
//!    into the binary (RFC 0013: Manifest-Driven Provider Registration)
//! 2. On Windows, locates and embeds bridge binaries (e.g., `MSBuild.exe`)
//!    so they can be deployed without shipping separate files

use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    embed_provider_manifests();
    embed_bridge_binaries();
}

fn embed_provider_manifests() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("provider_manifests.rs");

    // Find the vx-providers directory relative to this crate
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let providers_dir = Path::new(&manifest_dir).join("../vx-providers");

    let mut manifests = Vec::new();

    if providers_dir.exists() {
        // Collect all provider.toml files
        if let Ok(entries) = fs::read_dir(&providers_dir) {
            for entry in entries.flatten() {
                let provider_dir = entry.path();
                if provider_dir.is_dir() {
                    let manifest_path = provider_dir.join("provider.toml");
                    if manifest_path.exists()
                        && let Ok(content) = fs::read_to_string(&manifest_path)
                    {
                        let name = provider_dir
                            .file_name()
                            .and_then(|n| n.to_str())
                            .unwrap_or("unknown")
                            .to_string();
                        manifests.push((name, content));
                    }
                }
            }
        }
    }

    // Sort manifests by name for deterministic output
    manifests.sort_by(|a, b| a.0.cmp(&b.0));

    // Generate the Rust code
    let mut code = String::new();
    code.push_str("// Auto-generated provider manifests\n");
    code.push_str("// Generated by build.rs at compile time\n\n");

    code.push_str("/// Embedded provider manifests (name, toml_content)\n");
    code.push_str("pub static PROVIDER_MANIFESTS: &[(&str, &str)] = &[\n");

    for (name, content) in &manifests {
        // Escape content as a standard string literal to avoid raw-string delimiter collisions
        let escaped = content.escape_default().to_string();
        code.push_str(&format!("    (\"{}\", \"{}\"),\n", name, escaped));
    }

    code.push_str("];\n\n");

    code.push_str(&format!(
        "/// Number of embedded provider manifests\npub const PROVIDER_COUNT: usize = {};\n",
        manifests.len()
    ));

    fs::write(&dest_path, code).unwrap();

    // Tell Cargo to rerun this script if any provider.toml changes
    if providers_dir.exists() {
        println!("cargo:rerun-if-changed={}", providers_dir.display());
        if let Ok(entries) = fs::read_dir(&providers_dir) {
            for entry in entries.flatten() {
                let manifest_path = entry.path().join("provider.toml");
                if manifest_path.exists() {
                    println!("cargo:rerun-if-changed={}", manifest_path.display());
                }
            }
        }
    }
}

/// Embed bridge binaries (Windows only).
///
/// On Windows, we embed `MSBuild.exe` (from `vx-msbuild-bridge`) directly into
/// the `vx` binary. This is done by searching the cargo target directory for the
/// compiled bridge binary and generating `include_bytes!` code.
///
/// For non-Windows targets, an empty byte slice is embedded instead.
fn embed_bridge_binaries() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("embedded_bridges.rs");

    let mut code = String::new();
    code.push_str("// Auto-generated embedded bridge binaries\n");
    code.push_str("// Generated by build.rs at compile time\n\n");

    // Only embed on Windows targets
    let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();
    if target_os == "windows" {
        if let Some(bridge_path) = find_msbuild_bridge() {
            // Use include_bytes! to embed the bridge binary
            let bridge_path_escaped = bridge_path.display().to_string().replace('\\', "\\\\");
            code.push_str(&format!(
                "/// Embedded MSBuild bridge binary (compiled from vx-msbuild-bridge)\n\
                 pub static MSBUILD_BRIDGE_BYTES: &[u8] = include_bytes!(\"{}\");\n",
                bridge_path_escaped
            ));
            println!("cargo:rerun-if-changed={}", bridge_path.display());
            eprintln!(
                "cargo:warning=Embedding MSBuild bridge from: {}",
                bridge_path.display()
            );
        } else {
            code.push_str(
                "/// MSBuild bridge binary not found at build time â€” will use filesystem fallback\n\
                 pub static MSBUILD_BRIDGE_BYTES: &[u8] = &[];\n",
            );
            eprintln!(
                "cargo:warning=MSBuild bridge binary not found, embedding empty placeholder. Build vx-msbuild-bridge first: cargo build -p vx-msbuild-bridge"
            );
        }
    } else {
        code.push_str(
            "/// MSBuild bridge is Windows-only\n\
             pub static MSBUILD_BRIDGE_BYTES: &[u8] = &[];\n",
        );
    }

    fs::write(&dest_path, code).unwrap();
}

/// Search for the compiled MSBuild bridge binary in the target directory.
///
/// We search both release and debug profiles, preferring the same profile
/// as the current build.
fn find_msbuild_bridge() -> Option<PathBuf> {
    let out_dir = env::var("OUT_DIR").ok()?;

    // OUT_DIR is something like: target/<profile>/build/vx-cli-<hash>/out
    // We need to navigate up to the target/<profile> directory
    let out_path = PathBuf::from(&out_dir);

    // Walk up to find the target directory
    // OUT_DIR = <target_dir>/<profile>/build/<crate>-<hash>/out
    let target_profile_dir = out_path.parent()?.parent()?.parent()?;
    let target_dir = target_profile_dir.parent()?;

    let bridge_name = "MSBuild.exe";

    // Try current profile first
    let current_profile_candidate = target_profile_dir.join(bridge_name);
    if current_profile_candidate.exists() {
        return Some(current_profile_candidate);
    }

    // Try release profile
    let release_candidate = target_dir.join("release").join(bridge_name);
    if release_candidate.exists() {
        return Some(release_candidate);
    }

    // Try debug profile
    let debug_candidate = target_dir.join("debug").join(bridge_name);
    if debug_candidate.exists() {
        return Some(debug_candidate);
    }

    None
}

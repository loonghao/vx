//! Build script for vx-cli
//!
//! This script collects all `provider.toml` manifests at compile time and embeds them
//! into the binary. This enables manifest-driven provider registration without runtime
//! file system access to the provider directories.
//!
//! See RFC 0013: Manifest-Driven Provider Registration

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("provider_manifests.rs");

    // Find the vx-providers directory relative to this crate
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let providers_dir = Path::new(&manifest_dir).join("../vx-providers");

    let mut manifests = Vec::new();

    if providers_dir.exists() {
        // Collect all provider.toml files
        if let Ok(entries) = fs::read_dir(&providers_dir) {
            for entry in entries.flatten() {
                let provider_dir = entry.path();
                if provider_dir.is_dir() {
                    let manifest_path = provider_dir.join("provider.toml");
                    if manifest_path.exists() {
                        if let Ok(content) = fs::read_to_string(&manifest_path) {
                            let name = provider_dir
                                .file_name()
                                .and_then(|n| n.to_str())
                                .unwrap_or("unknown")
                                .to_string();
                            manifests.push((name, content));
                        }
                    }
                }
            }
        }
    }

    // Sort manifests by name for deterministic output
    manifests.sort_by(|a, b| a.0.cmp(&b.0));

    // Generate the Rust code
    let mut code = String::new();
    code.push_str("// Auto-generated provider manifests\n");
    code.push_str("// Generated by build.rs at compile time\n\n");

    code.push_str("/// Embedded provider manifests (name, toml_content)\n");
    code.push_str("pub static PROVIDER_MANIFESTS: &[(&str, &str)] = &[\n");

    for (name, content) in &manifests {
        // Escape content as a standard string literal to avoid raw-string delimiter collisions
        let escaped = content.escape_default().to_string();
        code.push_str(&format!("    (\"{}\", \"{}\"),\n", name, escaped));
    }

    code.push_str("];\n\n");

    code.push_str(&format!(
        "/// Number of embedded provider manifests\npub const PROVIDER_COUNT: usize = {};\n",
        manifests.len()
    ));

    fs::write(&dest_path, code).unwrap();

    // Tell Cargo to rerun this script if any provider.toml changes
    if providers_dir.exists() {
        println!("cargo:rerun-if-changed={}", providers_dir.display());
        if let Ok(entries) = fs::read_dir(&providers_dir) {
            for entry in entries.flatten() {
                let manifest_path = entry.path().join("provider.toml");
                if manifest_path.exists() {
                    println!("cargo:rerun-if-changed={}", manifest_path.display());
                }
            }
        }
    }
}

//! Container configuration and Dockerfile generation
//!
//! This module provides functionality for:
//! - Generating Dockerfiles from configuration
//! - Multi-stage build support
//! - Registry integration
//! - Image tagging strategies

use crate::error::{ConfigError, ConfigResult};
use crate::types::{
    BuildStage, ContainerBuildConfig, ContainerConfig, CopyInstruction, DockerfileConfig, VxConfig,
};
use std::path::Path;

/// Container manager for Dockerfile generation and registry operations
pub struct ContainerManager {
    config: ContainerConfig,
    project_name: String,
}

impl ContainerManager {
    /// Create a new container manager
    pub fn new(config: ContainerConfig, project_name: String) -> Self {
        Self {
            config,
            project_name,
        }
    }

    /// Create from VxConfig
    pub fn from_vx_config(vx_config: &VxConfig) -> Option<Self> {
        let container = vx_config.container.clone()?;
        let project_name = vx_config
            .project
            .as_ref()
            .and_then(|p| p.name.clone())
            .unwrap_or_else(|| "app".to_string());
        Some(Self::new(container, project_name))
    }

    /// Check if container support is enabled
    pub fn is_enabled(&self) -> bool {
        self.config.enabled.unwrap_or(false)
    }

    /// Get the container runtime (docker or podman)
    pub fn runtime(&self) -> &str {
        self.config.runtime.as_deref().unwrap_or("docker")
    }

    /// Generate Dockerfile content
    pub fn generate_dockerfile(&self) -> ConfigResult<String> {
        let dockerfile_config =
            self.config
                .dockerfile
                .as_ref()
                .ok_or_else(|| ConfigError::Validation {
                    message: "No dockerfile configuration".into(),
                })?;

        let build_config = self.config.build.as_ref();

        if build_config.and_then(|b| b.multi_stage).unwrap_or(false) {
            self.generate_multistage_dockerfile(dockerfile_config, build_config.unwrap())
        } else {
            self.generate_simple_dockerfile(dockerfile_config)
        }
    }

    /// Generate a simple (single-stage) Dockerfile
    fn generate_simple_dockerfile(&self, config: &DockerfileConfig) -> ConfigResult<String> {
        let mut lines = Vec::new();

        // Header comment
        lines.push("# Generated by vx - DO NOT EDIT MANUALLY".to_string());
        lines.push(format!("# Project: {}", self.project_name));
        lines.push(String::new());

        // Base image
        let base_image = config
            .base_image
            .as_deref()
            .unwrap_or("debian:bookworm-slim");
        lines.push(format!("FROM {}", base_image));
        lines.push(String::new());

        // Labels
        if !config.labels.is_empty() {
            for (key, value) in &config.labels {
                lines.push(format!("LABEL {}=\"{}\"", key, value));
            }
            lines.push(String::new());
        }

        // Environment variables
        if !config.env.is_empty() {
            for (key, value) in &config.env {
                lines.push(format!("ENV {}=\"{}\"", key, value));
            }
            lines.push(String::new());
        }

        // Install packages
        if !config.packages.is_empty() {
            lines.push("RUN apt-get update && apt-get install -y \\".to_string());
            for pkg in &config.packages {
                lines.push(format!("    {} \\", pkg));
            }
            lines.push("    && rm -rf /var/lib/apt/lists/*".to_string());
            lines.push(String::new());
        }

        // Working directory
        if let Some(workdir) = &config.workdir {
            lines.push(format!("WORKDIR {}", workdir));
            lines.push(String::new());
        }

        // User
        if let Some(user) = &config.user {
            lines.push(format!("USER {}", user));
            lines.push(String::new());
        }

        // Copy instructions
        for copy in &config.copy {
            lines.push(self.format_copy_instruction(copy));
        }
        if !config.copy.is_empty() {
            lines.push(String::new());
        }

        // Run commands
        for cmd in &config.run {
            lines.push(format!("RUN {}", cmd));
        }
        if !config.run.is_empty() {
            lines.push(String::new());
        }

        // Expose ports
        for port in &config.expose {
            lines.push(format!("EXPOSE {}", port));
        }
        if !config.expose.is_empty() {
            lines.push(String::new());
        }

        // Healthcheck
        if let Some(healthcheck) = &config.healthcheck {
            let mut hc_parts = vec![format!("CMD {}", healthcheck.cmd)];
            if let Some(interval) = &healthcheck.interval {
                hc_parts.insert(0, format!("--interval={}", interval));
            }
            if let Some(timeout) = &healthcheck.timeout {
                hc_parts.insert(0, format!("--timeout={}", timeout));
            }
            if let Some(start_period) = &healthcheck.start_period {
                hc_parts.insert(0, format!("--start-period={}", start_period));
            }
            if let Some(retries) = healthcheck.retries {
                hc_parts.insert(0, format!("--retries={}", retries));
            }
            lines.push(format!("HEALTHCHECK {}", hc_parts.join(" ")));
            lines.push(String::new());
        }

        // Entrypoint
        if let Some(entrypoint) = &config.entrypoint {
            let ep_json: Vec<String> = entrypoint.iter().map(|s| format!("\"{}\"", s)).collect();
            lines.push(format!("ENTRYPOINT [{}]", ep_json.join(", ")));
        }

        // CMD
        if let Some(cmd) = &config.cmd {
            let cmd_json: Vec<String> = cmd.iter().map(|s| format!("\"{}\"", s)).collect();
            lines.push(format!("CMD [{}]", cmd_json.join(", ")));
        }

        Ok(lines.join("\n"))
    }

    /// Generate a multi-stage Dockerfile
    fn generate_multistage_dockerfile(
        &self,
        config: &DockerfileConfig,
        build_config: &ContainerBuildConfig,
    ) -> ConfigResult<String> {
        let mut lines = Vec::new();

        // Header comment
        lines.push("# Generated by vx - DO NOT EDIT MANUALLY".to_string());
        lines.push(format!(
            "# Project: {} (multi-stage build)",
            self.project_name
        ));
        lines.push(String::new());

        // Build arguments
        if !build_config.args.is_empty() {
            for (key, value) in &build_config.args {
                if value.is_empty() {
                    lines.push(format!("ARG {}", key));
                } else {
                    lines.push(format!("ARG {}={}", key, value));
                }
            }
            lines.push(String::new());
        }

        // Generate each stage
        for stage in &build_config.stages {
            lines.push(self.generate_stage(stage)?);
            lines.push(String::new());
        }

        // Final stage (from simple config)
        let base_image = config
            .base_image
            .as_deref()
            .unwrap_or("debian:bookworm-slim");
        lines.push(format!("FROM {} AS final", base_image));

        // Labels
        if !config.labels.is_empty() {
            for (key, value) in &config.labels {
                lines.push(format!("LABEL {}=\"{}\"", key, value));
            }
        }

        // Environment variables
        if !config.env.is_empty() {
            for (key, value) in &config.env {
                lines.push(format!("ENV {}=\"{}\"", key, value));
            }
        }

        // Working directory
        if let Some(workdir) = &config.workdir {
            lines.push(format!("WORKDIR {}", workdir));
        }

        // User
        if let Some(user) = &config.user {
            lines.push(format!("USER {}", user));
        }

        // Copy from stages
        for copy in &config.copy {
            lines.push(self.format_copy_instruction(copy));
        }

        // Expose ports
        for port in &config.expose {
            lines.push(format!("EXPOSE {}", port));
        }

        // Healthcheck
        if let Some(healthcheck) = &config.healthcheck {
            let mut hc_parts = vec![format!("CMD {}", healthcheck.cmd)];
            if let Some(interval) = &healthcheck.interval {
                hc_parts.insert(0, format!("--interval={}", interval));
            }
            if let Some(timeout) = &healthcheck.timeout {
                hc_parts.insert(0, format!("--timeout={}", timeout));
            }
            if let Some(start_period) = &healthcheck.start_period {
                hc_parts.insert(0, format!("--start-period={}", start_period));
            }
            if let Some(retries) = healthcheck.retries {
                hc_parts.insert(0, format!("--retries={}", retries));
            }
            lines.push(format!("HEALTHCHECK {}", hc_parts.join(" ")));
        }

        // Entrypoint
        if let Some(entrypoint) = &config.entrypoint {
            let ep_json: Vec<String> = entrypoint.iter().map(|s| format!("\"{}\"", s)).collect();
            lines.push(format!("ENTRYPOINT [{}]", ep_json.join(", ")));
        }

        // CMD
        if let Some(cmd) = &config.cmd {
            let cmd_json: Vec<String> = cmd.iter().map(|s| format!("\"{}\"", s)).collect();
            lines.push(format!("CMD [{}]", cmd_json.join(", ")));
        }

        Ok(lines.join("\n"))
    }

    /// Generate a single build stage
    fn generate_stage(&self, stage: &BuildStage) -> ConfigResult<String> {
        let mut lines = Vec::new();

        lines.push(format!("FROM {} AS {}", stage.base_image, stage.name));

        // Stage-specific args
        for arg in &stage.args {
            lines.push(format!("ARG {}", arg));
        }

        // Environment variables
        for (key, value) in &stage.env {
            lines.push(format!("ENV {}=\"{}\"", key, value));
        }

        // Working directory
        if let Some(workdir) = &stage.workdir {
            lines.push(format!("WORKDIR {}", workdir));
        }

        // Copy instructions
        for copy in &stage.copy {
            lines.push(self.format_copy_instruction(copy));
        }

        // Run commands
        for cmd in &stage.run {
            lines.push(format!("RUN {}", cmd));
        }

        Ok(lines.join("\n"))
    }

    /// Format a COPY instruction
    fn format_copy_instruction(&self, copy: &CopyInstruction) -> String {
        let mut parts = vec!["COPY".to_string()];

        if let Some(from) = &copy.from {
            parts.push(format!("--from={}", from));
        }

        if let Some(chown) = &copy.chown {
            parts.push(format!("--chown={}", chown));
        }

        parts.push(copy.src.clone());
        parts.push(copy.dest.clone());

        parts.join(" ")
    }

    /// Generate .dockerignore content
    pub fn generate_dockerignore(&self) -> String {
        let mut lines = vec![
            "# Generated by vx".to_string(),
            String::new(),
            "# Git".to_string(),
            ".git".to_string(),
            ".gitignore".to_string(),
            String::new(),
            "# IDE".to_string(),
            ".idea".to_string(),
            ".vscode".to_string(),
            "*.swp".to_string(),
            "*.swo".to_string(),
            String::new(),
            "# Build artifacts".to_string(),
            "target/".to_string(),
            "dist/".to_string(),
            "build/".to_string(),
            "node_modules/".to_string(),
            "__pycache__/".to_string(),
            "*.pyc".to_string(),
            String::new(),
            "# Docker".to_string(),
            "Dockerfile*".to_string(),
            "docker-compose*.yml".to_string(),
            ".dockerignore".to_string(),
            String::new(),
            "# Documentation".to_string(),
            "*.md".to_string(),
            "docs/".to_string(),
            String::new(),
            "# Tests".to_string(),
            "tests/".to_string(),
            "test/".to_string(),
            "*_test.go".to_string(),
            "*_test.rs".to_string(),
            String::new(),
        ];

        // Add custom ignore patterns
        if let Some(dockerfile_config) = &self.config.dockerfile
            && !dockerfile_config.ignore.is_empty()
        {
            lines.push("# Custom ignores".to_string());
            for pattern in &dockerfile_config.ignore {
                lines.push(pattern.clone());
            }
        }

        lines.join("\n")
    }

    /// Generate image tags based on configuration
    pub fn generate_tags(&self, git_info: &GitInfo) -> Vec<String> {
        let tags_config = self.config.tags.as_ref();
        let registry = self.config.registry.as_ref();

        let image_name = registry
            .and_then(|r| r.image.clone())
            .unwrap_or_else(|| self.project_name.clone());

        let registry_url = registry.and_then(|r| r.url.clone());

        let full_image_name = match registry_url {
            Some(url) => format!("{}/{}", url.trim_end_matches('/'), image_name),
            None => image_name,
        };

        let mut tags = Vec::new();

        let prefix = tags_config
            .and_then(|t| t.prefix.clone())
            .unwrap_or_default();
        let suffix = tags_config
            .and_then(|t| t.suffix.clone())
            .unwrap_or_default();

        // Latest tag
        if tags_config.and_then(|t| t.latest).unwrap_or(true) {
            tags.push(format!("{}:{}latest{}", full_image_name, prefix, suffix));
        }

        // Git SHA tag
        if tags_config.and_then(|t| t.git_sha).unwrap_or(true)
            && let Some(sha) = &git_info.sha
        {
            let sha_len = tags_config.and_then(|t| t.sha_length).unwrap_or(7) as usize;
            let short_sha = &sha[..sha_len.min(sha.len())];
            tags.push(format!(
                "{}:{}{}{}",
                full_image_name, prefix, short_sha, suffix
            ));
        }

        // Branch tag
        if tags_config.and_then(|t| t.branch).unwrap_or(false)
            && let Some(branch) = &git_info.branch
        {
            let sanitized = sanitize_tag(branch);
            tags.push(format!(
                "{}:{}{}{}",
                full_image_name, prefix, sanitized, suffix
            ));
        }

        // Timestamp tag
        if tags_config.and_then(|t| t.timestamp).unwrap_or(false) {
            let format = tags_config
                .and_then(|t| t.timestamp_format.clone())
                .unwrap_or_else(|| "%Y%m%d%H%M%S".to_string());
            let timestamp = chrono::Utc::now().format(&format).to_string();
            tags.push(format!(
                "{}:{}{}{}",
                full_image_name, prefix, timestamp, suffix
            ));
        }

        // Version tag (from git tag)
        if let Some(version) = &git_info.tag {
            tags.push(format!(
                "{}:{}{}{}",
                full_image_name, prefix, version, suffix
            ));
        }

        // Custom tags
        if let Some(config) = tags_config {
            for custom_tag in &config.custom {
                tags.push(format!("{}:{}", full_image_name, custom_tag));
            }
        }

        tags
    }

    /// Generate build command
    pub fn generate_build_command(&self, tags: &[String]) -> Vec<String> {
        let runtime = self.runtime();
        let mut cmd = vec![runtime.to_string(), "build".to_string()];

        // Add tags
        for tag in tags {
            cmd.push("-t".to_string());
            cmd.push(tag.clone());
        }

        // Add build args
        if let Some(build_config) = &self.config.build {
            for (key, value) in &build_config.args {
                cmd.push("--build-arg".to_string());
                cmd.push(format!("{}={}", key, value));
            }

            // Add target stage
            if let Some(target) = &build_config.target {
                cmd.push("--target".to_string());
                cmd.push(target.clone());
            }

            // Add platforms
            if !build_config.platforms.is_empty() {
                cmd.push("--platform".to_string());
                cmd.push(build_config.platforms.join(","));
            }

            // Add cache configuration
            if let Some(cache) = &build_config.cache
                && cache.enabled.unwrap_or(false)
            {
                for cache_from in &cache.cache_from {
                    cmd.push("--cache-from".to_string());
                    cmd.push(cache_from.clone());
                }
                if let Some(cache_to) = &cache.cache_to {
                    cmd.push("--cache-to".to_string());
                    cmd.push(cache_to.clone());
                }
            }

            // Add context
            if let Some(context) = &build_config.context {
                cmd.push(context.clone());
            } else {
                cmd.push(".".to_string());
            }
        } else {
            cmd.push(".".to_string());
        }

        // Add dockerfile path
        if let Some(dockerfile_config) = &self.config.dockerfile
            && let Some(output) = &dockerfile_config.output
        {
            cmd.insert(2, "-f".to_string());
            cmd.insert(3, output.clone());
        }

        cmd
    }

    /// Generate push command
    pub fn generate_push_command(&self, tag: &str) -> Vec<String> {
        let runtime = self.runtime();
        vec![runtime.to_string(), "push".to_string(), tag.to_string()]
    }

    /// Write Dockerfile to disk
    pub fn write_dockerfile(&self, project_root: &Path) -> ConfigResult<()> {
        let content = self.generate_dockerfile()?;
        let output_path = self
            .config
            .dockerfile
            .as_ref()
            .and_then(|d| d.output.clone())
            .unwrap_or_else(|| "Dockerfile".to_string());

        let full_path = project_root.join(&output_path);
        std::fs::write(&full_path, content)
            .map_err(|e| ConfigError::IoError(format!("Failed to write Dockerfile: {}", e)))?;

        Ok(())
    }

    /// Write .dockerignore to disk
    pub fn write_dockerignore(&self, project_root: &Path) -> ConfigResult<()> {
        let content = self.generate_dockerignore();
        let full_path = project_root.join(".dockerignore");
        std::fs::write(&full_path, content)
            .map_err(|e| ConfigError::IoError(format!("Failed to write .dockerignore: {}", e)))?;

        Ok(())
    }
}

/// Git information for tag generation
#[derive(Debug, Clone, Default)]
pub struct GitInfo {
    /// Current commit SHA
    pub sha: Option<String>,
    /// Current branch name
    pub branch: Option<String>,
    /// Current tag (if on a tag)
    pub tag: Option<String>,
}

impl GitInfo {
    /// Get git info from current directory
    pub fn from_current_dir() -> Self {
        let sha = std::process::Command::new("git")
            .args(["rev-parse", "HEAD"])
            .output()
            .ok()
            .and_then(|o| {
                if o.status.success() {
                    String::from_utf8(o.stdout)
                        .ok()
                        .map(|s| s.trim().to_string())
                } else {
                    None
                }
            });

        let branch = std::process::Command::new("git")
            .args(["rev-parse", "--abbrev-ref", "HEAD"])
            .output()
            .ok()
            .and_then(|o| {
                if o.status.success() {
                    String::from_utf8(o.stdout)
                        .ok()
                        .map(|s| s.trim().to_string())
                } else {
                    None
                }
            });

        let tag = std::process::Command::new("git")
            .args(["describe", "--tags", "--exact-match"])
            .output()
            .ok()
            .and_then(|o| {
                if o.status.success() {
                    String::from_utf8(o.stdout)
                        .ok()
                        .map(|s| s.trim().to_string())
                } else {
                    None
                }
            });

        Self { sha, branch, tag }
    }
}

/// Sanitize a string for use as a Docker tag
fn sanitize_tag(s: &str) -> String {
    s.chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '-' || c == '_' || c == '.' {
                c
            } else {
                '-'
            }
        })
        .collect::<String>()
        .trim_matches('-')
        .to_string()
}

/// Dockerfile generator for specific ecosystems
pub struct DockerfileGenerator;

impl DockerfileGenerator {
    /// Generate a Node.js Dockerfile
    pub fn nodejs(config: &NodejsDockerConfig) -> String {
        let mut lines = vec![
            "# Node.js application".to_string(),
            format!("FROM node:{}-alpine AS builder", config.node_version),
            "WORKDIR /app".to_string(),
            String::new(),
            "# Install dependencies".to_string(),
            "COPY package*.json ./".to_string(),
        ];

        let install_cmd = match config.package_manager.as_str() {
            "yarn" => "yarn install --frozen-lockfile",
            "pnpm" => "pnpm install --frozen-lockfile",
            _ => "npm ci",
        };
        lines.push(format!("RUN {}", install_cmd));

        lines.extend(vec![
            String::new(),
            "# Build application".to_string(),
            "COPY . .".to_string(),
            format!("RUN {} run build", config.package_manager),
            String::new(),
            "# Production stage".to_string(),
            format!("FROM node:{}-alpine", config.node_version),
            "WORKDIR /app".to_string(),
            String::new(),
            "COPY --from=builder /app/dist ./dist".to_string(),
            "COPY --from=builder /app/node_modules ./node_modules".to_string(),
            "COPY --from=builder /app/package.json ./".to_string(),
            String::new(),
            format!("EXPOSE {}", config.port),
            String::new(),
            format!("CMD [\"{}\", \"start\"]", config.package_manager),
        ]);

        lines.join("\n")
    }

    /// Generate a Python Dockerfile
    pub fn python(config: &PythonDockerConfig) -> String {
        let mut lines = vec![
            "# Python application".to_string(),
            format!("FROM python:{}-slim AS builder", config.python_version),
            "WORKDIR /app".to_string(),
            String::new(),
            "# Install build dependencies".to_string(),
            "RUN apt-get update && apt-get install -y --no-install-recommends \\".to_string(),
            "    build-essential \\".to_string(),
            "    && rm -rf /var/lib/apt/lists/*".to_string(),
            String::new(),
            "# Install Python dependencies".to_string(),
        ];

        if config.use_uv {
            lines.extend(vec![
                "COPY --from=ghcr.io/astral-sh/uv:latest /uv /usr/local/bin/uv".to_string(),
                "COPY pyproject.toml uv.lock* ./".to_string(),
                "RUN uv sync --frozen --no-dev".to_string(),
            ]);
        } else {
            lines.extend(vec![
                "COPY requirements.txt ./".to_string(),
                "RUN pip install --no-cache-dir -r requirements.txt".to_string(),
            ]);
        }

        lines.extend(vec![
            String::new(),
            "# Copy application".to_string(),
            "COPY . .".to_string(),
            String::new(),
            "# Production stage".to_string(),
            format!("FROM python:{}-slim", config.python_version),
            "WORKDIR /app".to_string(),
            String::new(),
        ]);

        if config.use_uv {
            lines.push("COPY --from=builder /app/.venv /app/.venv".to_string());
            lines.push("ENV PATH=\"/app/.venv/bin:$PATH\"".to_string());
        } else {
            lines.push("COPY --from=builder /usr/local/lib/python*/site-packages /usr/local/lib/python*/site-packages".to_string());
        }

        lines.extend(vec![
            "COPY --from=builder /app .".to_string(),
            String::new(),
            format!("EXPOSE {}", config.port),
            String::new(),
            format!("CMD [\"python\", \"{}\"]", config.entrypoint),
        ]);

        lines.join("\n")
    }

    /// Generate a Rust Dockerfile
    pub fn rust(config: &RustDockerConfig) -> String {
        let lines = vec![
            "# Rust application".to_string(),
            format!("FROM rust:{} AS builder", config.rust_version),
            "WORKDIR /app".to_string(),
            String::new(),
            "# Create a dummy project to cache dependencies".to_string(),
            "RUN cargo new --bin dummy".to_string(),
            "WORKDIR /app/dummy".to_string(),
            "COPY Cargo.toml Cargo.lock ./".to_string(),
            "RUN cargo build --release && rm -rf src".to_string(),
            String::new(),
            "# Build actual application".to_string(),
            "WORKDIR /app".to_string(),
            "COPY . .".to_string(),
            "RUN cargo build --release".to_string(),
            String::new(),
            "# Production stage".to_string(),
            "FROM debian:bookworm-slim".to_string(),
            String::new(),
            "RUN apt-get update && apt-get install -y --no-install-recommends \\".to_string(),
            "    ca-certificates \\".to_string(),
            "    && rm -rf /var/lib/apt/lists/*".to_string(),
            String::new(),
            format!(
                "COPY --from=builder /app/target/release/{} /usr/local/bin/",
                config.binary_name
            ),
            String::new(),
            format!("EXPOSE {}", config.port),
            String::new(),
            format!("CMD [\"{}\"]", config.binary_name),
        ];

        lines.join("\n")
    }

    /// Generate a Go Dockerfile
    pub fn go(config: &GoDockerConfig) -> String {
        let lines = vec![
            "# Go application".to_string(),
            format!("FROM golang:{}-alpine AS builder", config.go_version),
            "WORKDIR /app".to_string(),
            String::new(),
            "# Download dependencies".to_string(),
            "COPY go.mod go.sum ./".to_string(),
            "RUN go mod download".to_string(),
            String::new(),
            "# Build application".to_string(),
            "COPY . .".to_string(),
            format!(
                "RUN CGO_ENABLED=0 GOOS=linux go build -ldflags='-w -s' -o {} {}",
                config.binary_name, config.main_package
            ),
            String::new(),
            "# Production stage".to_string(),
            "FROM alpine:latest".to_string(),
            String::new(),
            "RUN apk --no-cache add ca-certificates".to_string(),
            String::new(),
            format!(
                "COPY --from=builder /app/{} /usr/local/bin/",
                config.binary_name
            ),
            String::new(),
            format!("EXPOSE {}", config.port),
            String::new(),
            format!("CMD [\"{}\"]", config.binary_name),
        ];

        lines.join("\n")
    }
}

/// Node.js Docker configuration
#[derive(Debug, Clone)]
pub struct NodejsDockerConfig {
    pub node_version: String,
    pub package_manager: String,
    pub port: u16,
}

impl Default for NodejsDockerConfig {
    fn default() -> Self {
        Self {
            node_version: "20".to_string(),
            package_manager: "npm".to_string(),
            port: 3000,
        }
    }
}

/// Python Docker configuration
#[derive(Debug, Clone)]
pub struct PythonDockerConfig {
    pub python_version: String,
    pub use_uv: bool,
    pub port: u16,
    pub entrypoint: String,
}

impl Default for PythonDockerConfig {
    fn default() -> Self {
        Self {
            python_version: "3.12".to_string(),
            use_uv: true,
            port: 8000,
            entrypoint: "main.py".to_string(),
        }
    }
}

/// Rust Docker configuration
#[derive(Debug, Clone)]
pub struct RustDockerConfig {
    pub rust_version: String,
    pub binary_name: String,
    pub port: u16,
}

impl Default for RustDockerConfig {
    fn default() -> Self {
        Self {
            rust_version: "1.75".to_string(),
            binary_name: "app".to_string(),
            port: 8080,
        }
    }
}

/// Go Docker configuration
#[derive(Debug, Clone)]
pub struct GoDockerConfig {
    pub go_version: String,
    pub binary_name: String,
    pub main_package: String,
    pub port: u16,
}

impl Default for GoDockerConfig {
    fn default() -> Self {
        Self {
            go_version: "1.22".to_string(),
            binary_name: "app".to_string(),
            main_package: "./cmd/app".to_string(),
            port: 8080,
        }
    }
}

/// Generate Dockerfile content from VxConfig
pub fn generate_dockerfile(config: &VxConfig) -> String {
    if let Some(manager) = ContainerManager::from_vx_config(config)
        && let Ok(dockerfile) = manager.generate_dockerfile()
    {
        return dockerfile;
    }

    // Fallback: detect project type and generate appropriate Dockerfile
    let tools = config.tools.keys().collect::<Vec<_>>();

    if tools
        .iter()
        .any(|t| *t == "node" || *t == "npm" || *t == "npx")
    {
        let node_version = config
            .get_tool_version("node")
            .unwrap_or_else(|| "20".to_string());
        let config = NodejsDockerConfig {
            node_version,
            ..Default::default()
        };
        return DockerfileGenerator::nodejs(&config);
    }

    if tools
        .iter()
        .any(|t| *t == "python" || *t == "uv" || *t == "pip")
    {
        let python_version = config
            .get_tool_version("python")
            .unwrap_or_else(|| "3.12".to_string());
        let config = PythonDockerConfig {
            python_version,
            use_uv: tools.iter().any(|t| *t == "uv"),
            ..Default::default()
        };
        return DockerfileGenerator::python(&config);
    }

    if tools.iter().any(|t| *t == "rust" || *t == "cargo") {
        let rust_version = config
            .get_tool_version("rust")
            .unwrap_or_else(|| "1.75".to_string());
        let project_name = config
            .project
            .as_ref()
            .and_then(|p| p.name.clone())
            .unwrap_or_else(|| "app".to_string());
        let config = RustDockerConfig {
            rust_version,
            binary_name: project_name,
            ..Default::default()
        };
        return DockerfileGenerator::rust(&config);
    }

    if tools.iter().any(|t| *t == "go") {
        let go_version = config
            .get_tool_version("go")
            .unwrap_or_else(|| "1.22".to_string());
        let project_name = config
            .project
            .as_ref()
            .and_then(|p| p.name.clone())
            .unwrap_or_else(|| "app".to_string());
        let config = GoDockerConfig {
            go_version,
            binary_name: project_name,
            ..Default::default()
        };
        return DockerfileGenerator::go(&config);
    }

    // Default minimal Dockerfile
    r#"# Generated by vx
FROM debian:bookworm-slim

WORKDIR /app
COPY . .

CMD ["/bin/bash"]
"#
    .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sanitize_tag() {
        assert_eq!(sanitize_tag("feature/test"), "feature-test");
        assert_eq!(sanitize_tag("v1.0.0"), "v1.0.0");
        assert_eq!(sanitize_tag("main"), "main");
        assert_eq!(sanitize_tag("feature/test-123"), "feature-test-123");
    }

    #[test]
    fn test_nodejs_dockerfile() {
        let config = NodejsDockerConfig::default();
        let dockerfile = DockerfileGenerator::nodejs(&config);
        assert!(dockerfile.contains("FROM node:20-alpine"));
        assert!(dockerfile.contains("npm ci"));
        assert!(dockerfile.contains("EXPOSE 3000"));
    }

    #[test]
    fn test_python_dockerfile() {
        let config = PythonDockerConfig::default();
        let dockerfile = DockerfileGenerator::python(&config);
        assert!(dockerfile.contains("FROM python:3.12-slim"));
        assert!(dockerfile.contains("uv sync"));
        assert!(dockerfile.contains("EXPOSE 8000"));
    }

    #[test]
    fn test_rust_dockerfile() {
        let config = RustDockerConfig::default();
        let dockerfile = DockerfileGenerator::rust(&config);
        assert!(dockerfile.contains("FROM rust:1.75"));
        assert!(dockerfile.contains("cargo build --release"));
        assert!(dockerfile.contains("EXPOSE 8080"));
    }

    #[test]
    fn test_go_dockerfile() {
        let config = GoDockerConfig::default();
        let dockerfile = DockerfileGenerator::go(&config);
        assert!(dockerfile.contains("FROM golang:1.22-alpine"));
        assert!(dockerfile.contains("go mod download"));
        assert!(dockerfile.contains("CGO_ENABLED=0"));
    }
}

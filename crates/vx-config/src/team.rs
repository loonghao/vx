//! Team configuration management
//!
//! This module handles team-related configurations including:
//! - Code owners generation
//! - Review rules
//! - Convention enforcement

use crate::{CodeOwnersConfig, ConventionsConfig, ReviewConfig, TeamConfig};
use std::collections::HashMap;

/// Team configuration manager
pub struct TeamManager;

impl TeamManager {
    /// Generate CODEOWNERS file content
    pub fn generate_codeowners(config: &CodeOwnersConfig) -> String {
        let mut lines = vec![
            "# This file is auto-generated by vx".to_string(),
            "# Do not edit manually - update .vx.toml instead".to_string(),
            String::new(),
        ];

        // Add default owners
        if !config.default_owners.is_empty() {
            lines.push(format!("* {}", config.default_owners.join(" ")));
        }

        // Add path-specific owners
        let mut paths: Vec<_> = config.paths.iter().collect();
        paths.sort_by_key(|(k, _)| *k);

        for (path, owners) in paths {
            if !owners.is_empty() {
                lines.push(format!("{} {}", path, owners.join(" ")));
            }
        }

        lines.join("\n")
    }

    /// Get CODEOWNERS output path
    pub fn codeowners_path(config: &CodeOwnersConfig) -> &str {
        config.output.as_deref().unwrap_or(".github/CODEOWNERS")
    }

    /// Validate commit message against conventions
    pub fn validate_commit_message(
        conventions: &ConventionsConfig,
        message: &str,
    ) -> Result<(), String> {
        // Check custom pattern first
        if let Some(pattern) = &conventions.commit_pattern {
            let re =
                regex::Regex::new(pattern).map_err(|e| format!("Invalid commit pattern: {}", e))?;
            if !re.is_match(message) {
                return Err(format!(
                    "Commit message does not match pattern: {}",
                    pattern
                ));
            }
            return Ok(());
        }

        // Check built-in formats
        match conventions.commit_format.as_deref() {
            Some("conventional") | Some("angular") => Self::validate_conventional_commit(message),
            _ => Ok(()),
        }
    }

    /// Validate conventional commit format
    fn validate_conventional_commit(message: &str) -> Result<(), String> {
        let pattern =
            r"^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?: .+";
        let re = regex::Regex::new(pattern).unwrap();

        if !re.is_match(message.lines().next().unwrap_or("")) {
            return Err(
                "Commit message must follow conventional commits format: <type>(<scope>): <description>"
                    .to_string(),
            );
        }
        Ok(())
    }

    /// Validate branch name against conventions
    pub fn validate_branch_name(
        conventions: &ConventionsConfig,
        branch: &str,
    ) -> Result<(), String> {
        if let Some(pattern) = &conventions.branch_pattern {
            let re =
                regex::Regex::new(pattern).map_err(|e| format!("Invalid branch pattern: {}", e))?;
            if !re.is_match(branch) {
                return Err(format!(
                    "Branch name '{}' does not match pattern: {}",
                    branch, pattern
                ));
            }
        }
        Ok(())
    }

    /// Generate review configuration summary
    pub fn review_summary(review: &ReviewConfig) -> HashMap<String, String> {
        let mut summary = HashMap::new();

        if let Some(approvals) = review.required_approvals {
            summary.insert("required_approvals".to_string(), approvals.to_string());
        }

        if let Some(code_owner) = review.require_code_owner {
            summary.insert("require_code_owner".to_string(), code_owner.to_string());
        }

        if let Some(dismiss) = review.dismiss_stale {
            summary.insert("dismiss_stale".to_string(), dismiss.to_string());
        }

        if !review.protected_branches.is_empty() {
            summary.insert(
                "protected_branches".to_string(),
                review.protected_branches.join(", "),
            );
        }

        summary
    }
}

/// Generate CODEOWNERS file content from TeamConfig
pub fn generate_codeowners(config: &TeamConfig) -> String {
    let Some(code_owners) = &config.code_owners else {
        return String::new();
    };

    TeamManager::generate_codeowners(code_owners)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_codeowners() {
        let config = CodeOwnersConfig {
            enabled: Some(true),
            default_owners: vec!["@team/core".to_string()],
            paths: {
                let mut m = HashMap::new();
                m.insert("*.rs".to_string(), vec!["@rust-team".to_string()]);
                m.insert("*.ts".to_string(), vec!["@ts-team".to_string()]);
                m
            },
            output: None,
        };

        let content = TeamManager::generate_codeowners(&config);
        assert!(content.contains("* @team/core"));
        assert!(content.contains("*.rs @rust-team"));
        assert!(content.contains("*.ts @ts-team"));
    }

    #[test]
    fn test_validate_conventional_commit() {
        assert!(TeamManager::validate_conventional_commit("feat: add new feature").is_ok());
        assert!(TeamManager::validate_conventional_commit("fix(core): fix bug").is_ok());
        assert!(TeamManager::validate_conventional_commit("invalid message").is_err());
    }
}

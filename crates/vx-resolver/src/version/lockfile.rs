//! Lock file implementation for reproducible environments
//!
//! This module provides the `LockFile` type for locking resolved versions
//! to ensure consistent tool versions across different machines and CI/CD.
//!
//! # Lock File Format
//!
//! The lock file uses TOML format:
//!
//! ```toml
//! # vx.lock - Auto-generated, do not edit manually
//! # Generated by vx 0.7.0
//!
//! [metadata]
//! generated_at = "2025-12-30T10:00:00Z"
//! vx_version = "0.7.0"
//! platform = "x86_64-pc-windows-msvc"
//!
//! [tools.python]
//! version = "3.11.11"
//! source = "python-build-standalone"
//! resolved_from = "3.11"
//! checksum = "sha256:abc123..."
//!
//! [dependencies]
//! npm = ["node"]
//! npx = ["node"]
//! ```

use super::constraint::Version;
use super::resolved::ResolvedVersion;
use crate::runtime_spec::Ecosystem;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;

/// Lock file version
pub const LOCK_FILE_VERSION: u32 = 2;

/// Lock file metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockFileMetadata {
    /// When the lock file was generated
    pub generated_at: String,
    /// vx version that generated the lock file
    pub vx_version: String,
    /// Platform the lock file was generated on
    pub platform: String,
}

impl Default for LockFileMetadata {
    fn default() -> Self {
        Self {
            generated_at: chrono_now(),
            vx_version: env!("CARGO_PKG_VERSION").to_string(),
            platform: current_platform(),
        }
    }
}

/// A locked tool entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedTool {
    /// Resolved version string (e.g., "3.11.11")
    pub version: String,
    /// Source (e.g., "python-build-standalone", "nodejs.org")
    pub source: String,
    /// Original version request (e.g., "3.11", "latest")
    pub resolved_from: String,
    /// Ecosystem of the tool
    #[serde(default)]
    pub ecosystem: Ecosystem,
    /// SHA256 checksum of the downloaded artifact
    #[serde(skip_serializing_if = "Option::is_none")]
    pub checksum: Option<String>,
    /// Download URL for the current platform
    #[serde(skip_serializing_if = "Option::is_none")]
    pub download_url: Option<String>,
    /// Platform-specific download URLs (platform -> URL)
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub platform_urls: HashMap<String, String>,
    /// Additional metadata
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub metadata: HashMap<String, String>,

    // === RFC 0023: Version Range Locking ===
    /// Original version range from vx.toml (e.g., "^5.0", "latest")
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub original_range: Option<String>,
    /// Pinning strategy used for this tool
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pinning: Option<String>,
    /// Whether this is the latest version within the range
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_latest_in_range: Option<bool>,
    /// Source of the version constraint: "user", "provider", or "merged"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub constraint_source: Option<String>,
    /// Provider's default range that was applied (when original was "latest")
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub applied_default: Option<String>,
}

impl LockedTool {
    /// Create a new locked tool entry
    pub fn new(version: impl Into<String>, source: impl Into<String>) -> Self {
        Self {
            version: version.into(),
            source: source.into(),
            resolved_from: String::new(),
            ecosystem: Ecosystem::Generic,
            checksum: None,
            download_url: None,
            platform_urls: HashMap::new(),
            metadata: HashMap::new(),
            // RFC 0023 fields
            original_range: None,
            pinning: None,
            is_latest_in_range: None,
            constraint_source: None,
            applied_default: None,
        }
    }

    /// Set the resolved_from field
    pub fn with_resolved_from(mut self, resolved_from: impl Into<String>) -> Self {
        self.resolved_from = resolved_from.into();
        self
    }

    /// Set the ecosystem
    pub fn with_ecosystem(mut self, ecosystem: Ecosystem) -> Self {
        self.ecosystem = ecosystem;
        self
    }

    /// Set the checksum
    pub fn with_checksum(mut self, checksum: impl Into<String>) -> Self {
        self.checksum = Some(checksum.into());
        self
    }

    /// Add metadata
    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.metadata.insert(key.into(), value.into());
        self
    }

    /// Set download URL for the current platform
    pub fn with_download_url(mut self, url: impl Into<String>) -> Self {
        self.download_url = Some(url.into());
        self
    }

    /// Add platform-specific download URL
    pub fn with_platform_url(mut self, platform: impl Into<String>, url: impl Into<String>) -> Self {
        self.platform_urls.insert(platform.into(), url.into());
        self
    }

    /// Get download URL for a specific platform
    ///
    /// Returns:
    /// 1. Platform-specific URL if available
    /// 2. Current platform URL as fallback
    /// 3. None if neither is available
    pub fn download_url_for_platform(&self, platform: &str) -> Option<&String> {
        // Try platform-specific URL first
        if let Some(url) = self.platform_urls.get(platform) {
            return Some(url);
        }
        // Fall back to current platform URL
        self.download_url.as_ref()
    }

    /// Parse the version string into a Version struct
    pub fn parsed_version(&self) -> Option<Version> {
        Version::parse(&self.version)
    }

    // === RFC 0023: Version Range Locking Methods ===

    /// Set the original version range from vx.toml
    pub fn with_original_range(mut self, range: impl Into<String>) -> Self {
        self.original_range = Some(range.into());
        self
    }

    /// Set the pinning strategy
    pub fn with_pinning(mut self, pinning: impl Into<String>) -> Self {
        self.pinning = Some(pinning.into());
        self
    }

    /// Set whether this is the latest version in the range
    pub fn with_is_latest_in_range(mut self, is_latest: bool) -> Self {
        self.is_latest_in_range = Some(is_latest);
        self
    }

    /// Set the constraint source
    pub fn with_constraint_source(mut self, source: impl Into<String>) -> Self {
        self.constraint_source = Some(source.into());
        self
    }

    /// Set the applied default range (from provider)
    pub fn with_applied_default(mut self, default: impl Into<String>) -> Self {
        self.applied_default = Some(default.into());
        self
    }
}

impl From<&ResolvedVersion> for LockedTool {
    fn from(resolved: &ResolvedVersion) -> Self {
        Self {
            version: resolved.version.to_string(),
            source: resolved.source.clone(),
            resolved_from: resolved.resolved_from.clone(),
            ecosystem: Ecosystem::Generic,
            checksum: resolved.get_metadata("checksum").cloned(),
            download_url: resolved.get_metadata("download_url").cloned(),
            platform_urls: resolved
                .get_metadata("platform_urls")
                .and_then(|v| serde_json::from_str(v).ok())
                .unwrap_or_default(),
            metadata: resolved.metadata.clone(),
            // RFC 0023 fields - extract from metadata if available
            original_range: resolved.get_metadata("original_range").cloned(),
            pinning: resolved.get_metadata("pinning").cloned(),
            is_latest_in_range: resolved
                .get_metadata("is_latest_in_range")
                .and_then(|v| v.parse().ok()),
            constraint_source: resolved.get_metadata("constraint_source").cloned(),
            applied_default: resolved.get_metadata("applied_default").cloned(),
        }
    }
}

/// Lock file for reproducible environments
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockFile {
    /// Lock file format version
    pub version: u32,
    /// Metadata about the lock file
    pub metadata: LockFileMetadata,
    /// Locked tool versions
    #[serde(default)]
    pub tools: HashMap<String, LockedTool>,
    /// Tool dependencies (e.g., npm -> [node])
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub dependencies: HashMap<String, Vec<String>>,
}

impl Default for LockFile {
    fn default() -> Self {
        Self {
            version: LOCK_FILE_VERSION,
            metadata: LockFileMetadata::default(),
            tools: HashMap::new(),
            dependencies: HashMap::new(),
        }
    }
}

impl LockFile {
    /// Create a new empty lock file
    pub fn new() -> Self {
        Self::default()
    }

    /// Load a lock file from a path
    pub fn load(path: impl AsRef<Path>) -> Result<Self, LockFileError> {
        let content = std::fs::read_to_string(path.as_ref()).map_err(|e| LockFileError::Io {
            path: path.as_ref().to_path_buf(),
            error: e.to_string(),
        })?;

        Self::parse(&content)
    }

    /// Load a lock file from a path with automatic migration
    ///
    /// If the lock file is version 1, it will be automatically migrated to version 2.
    /// The migrated file is NOT automatically saved - call `save()` explicitly.
    pub fn load_with_migration(path: impl AsRef<Path>) -> Result<(Self, bool), LockFileError> {
        let content = std::fs::read_to_string(path.as_ref()).map_err(|e| LockFileError::Io {
            path: path.as_ref().to_path_buf(),
            error: e.to_string(),
        })?;

        let mut lockfile: Self = toml::from_str(&content).map_err(|e| LockFileError::Parse {
            error: e.to_string(),
        })?;

        let migrated = if lockfile.version < LOCK_FILE_VERSION {
            lockfile.migrate_to_current();
            true
        } else {
            false
        };

        Ok((lockfile, migrated))
    }

    /// Migrate lock file to the current version
    ///
    /// This method updates the lock file format from older versions to the current version.
    pub fn migrate_to_current(&mut self) {
        // Migrate from v1 to v2
        if self.version < 2 {
            self.version = 2;
            
            // Update metadata
            self.metadata.vx_version = env!("CARGO_PKG_VERSION").to_string();
            self.metadata.generated_at = chrono_now();
            
            // Fill in missing RFC 0023 fields for existing tools
            for (_name, tool) in &mut self.tools {
                // Set default values for new fields if not present
                if tool.original_range.is_none() {
                    tool.original_range = Some(tool.resolved_from.clone());
                }
                if tool.constraint_source.is_none() {
                    tool.constraint_source = Some("user".to_string());
                }
                // Mark tools that might need URL refresh
                if tool.download_url.is_none() && tool.platform_urls.is_empty() {
                    tool.metadata.insert("_needs_refresh".to_string(), "true".to_string());
                }
            }
        }
    }

    /// Check if the lock file needs migration
    pub fn needs_migration(&self) -> bool {
        self.version < LOCK_FILE_VERSION
    }

    /// Get the current lock file version
    pub fn current_version() -> u32 {
        LOCK_FILE_VERSION
    }

    /// Parse a lock file from a string
    pub fn parse(content: &str) -> Result<Self, LockFileError> {
        toml::from_str(content).map_err(|e| LockFileError::Parse {
            error: e.to_string(),
        })
    }

    /// Save the lock file to a path
    pub fn save(&self, path: impl AsRef<Path>) -> Result<(), LockFileError> {
        let content = self.to_string()?;

        // Ensure parent directory exists
        if let Some(parent) = path.as_ref().parent() {
            std::fs::create_dir_all(parent).map_err(|e| LockFileError::Io {
                path: parent.to_path_buf(),
                error: e.to_string(),
            })?;
        }

        std::fs::write(path.as_ref(), content).map_err(|e| LockFileError::Io {
            path: path.as_ref().to_path_buf(),
            error: e.to_string(),
        })
    }

    /// Serialize the lock file to a string
    pub fn to_string(&self) -> Result<String, LockFileError> {
        let header = format!(
            "# vx.lock - Auto-generated, do not edit manually\n# Generated by vx {}\n\n",
            self.metadata.vx_version
        );

        let content = toml::to_string_pretty(self).map_err(|e| LockFileError::Serialize {
            error: e.to_string(),
        })?;

        Ok(format!("{}{}", header, content))
    }

    /// Add or update a locked tool
    pub fn lock_tool(&mut self, name: impl Into<String>, tool: LockedTool) {
        self.tools.insert(name.into(), tool);
        self.metadata.generated_at = chrono_now();
    }

    /// Get a locked tool by name
    pub fn get_tool(&self, name: &str) -> Option<&LockedTool> {
        self.tools.get(name)
    }

    /// Remove a locked tool
    pub fn unlock_tool(&mut self, name: &str) -> Option<LockedTool> {
        self.tools.remove(name)
    }

    /// Check if a tool is locked
    pub fn is_locked(&self, name: &str) -> bool {
        self.tools.contains_key(name)
    }

    /// Get all locked tool names
    pub fn tool_names(&self) -> Vec<&str> {
        self.tools.keys().map(|s| s.as_str()).collect()
    }

    /// Add a dependency relationship
    pub fn add_dependency(&mut self, tool: impl Into<String>, depends_on: Vec<String>) {
        self.dependencies.insert(tool.into(), depends_on);
    }

    /// Get dependencies for a tool
    pub fn get_dependencies(&self, tool: &str) -> Option<&Vec<String>> {
        self.dependencies.get(tool)
    }

    /// Check if the lock file is consistent with a vx.toml configuration
    ///
    /// Returns a list of inconsistencies if any are found.
    pub fn check_consistency(
        &self,
        config_tools: &HashMap<String, String>,
    ) -> Vec<LockFileInconsistency> {
        let mut inconsistencies = Vec::new();

        // Check for tools in config but not in lock
        for (name, version) in config_tools {
            match self.tools.get(name) {
                None => {
                    inconsistencies.push(LockFileInconsistency::MissingInLock {
                        tool: name.clone(),
                        config_version: version.clone(),
                    });
                }
                Some(locked) => {
                    if &locked.resolved_from != version {
                        inconsistencies.push(LockFileInconsistency::VersionMismatch {
                            tool: name.clone(),
                            config_version: version.clone(),
                            locked_from: locked.resolved_from.clone(),
                        });
                    }
                }
            }
        }

        // Check for tools in lock but not in config
        for name in self.tools.keys() {
            if !config_tools.contains_key(name) {
                inconsistencies.push(LockFileInconsistency::ExtraInLock { tool: name.clone() });
            }
        }

        inconsistencies
    }

    /// Merge another lock file into this one
    ///
    /// Tools from `other` will overwrite tools in `self` if they exist.
    pub fn merge(&mut self, other: &LockFile) {
        for (name, tool) in &other.tools {
            self.tools.insert(name.clone(), tool.clone());
        }
        for (name, deps) in &other.dependencies {
            self.dependencies.insert(name.clone(), deps.clone());
        }
        self.metadata.generated_at = chrono_now();
    }

    /// Create a lock file from resolved versions
    pub fn from_resolved(resolved: &HashMap<String, ResolvedVersion>) -> Self {
        let mut lockfile = Self::new();
        for (name, version) in resolved {
            lockfile.lock_tool(name.clone(), LockedTool::from(version));
        }
        lockfile
    }
}

/// Lock file errors
#[derive(Debug, Clone)]
pub enum LockFileError {
    /// IO error
    Io {
        path: std::path::PathBuf,
        error: String,
    },
    /// Parse error
    Parse { error: String },
    /// Serialization error
    Serialize { error: String },
}

impl std::fmt::Display for LockFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Io { path, error } => {
                write!(f, "Failed to access '{}': {}", path.display(), error)
            }
            Self::Parse { error } => write!(f, "Failed to parse lock file: {}", error),
            Self::Serialize { error } => write!(f, "Failed to serialize lock file: {}", error),
        }
    }
}

impl std::error::Error for LockFileError {}

/// Lock file inconsistency types
#[derive(Debug, Clone)]
pub enum LockFileInconsistency {
    /// Tool is in config but not in lock file
    MissingInLock {
        tool: String,
        config_version: String,
    },
    /// Tool is in lock file but not in config
    ExtraInLock { tool: String },
    /// Version request changed
    VersionMismatch {
        tool: String,
        config_version: String,
        locked_from: String,
    },
}

impl std::fmt::Display for LockFileInconsistency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::MissingInLock {
                tool,
                config_version,
            } => {
                write!(
                    f,
                    "Tool '{}' ({}) is in vx.toml but not locked",
                    tool, config_version
                )
            }
            Self::ExtraInLock { tool } => {
                write!(f, "Tool '{}' is locked but not in vx.toml", tool)
            }
            Self::VersionMismatch {
                tool,
                config_version,
                locked_from,
            } => {
                write!(
                    f,
                    "Tool '{}' version changed: vx.toml has '{}', lock has '{}'",
                    tool, config_version, locked_from
                )
            }
        }
    }
}

// Helper functions

/// Get current timestamp in ISO 8601 format
fn chrono_now() -> String {
    use std::time::SystemTime;
    let now = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap_or_default();
    // Simple ISO 8601 format without external dependency
    let secs = now.as_secs();
    let days = secs / 86400;
    let remaining = secs % 86400;
    let hours = remaining / 3600;
    let minutes = (remaining % 3600) / 60;
    let seconds = remaining % 60;

    // Calculate year/month/day from days since epoch (1970-01-01)
    let (year, month, day) = days_to_ymd(days);

    format!(
        "{:04}-{:02}-{:02}T{:02}:{:02}:{:02}Z",
        year, month, day, hours, minutes, seconds
    )
}

/// Convert days since epoch to year/month/day
fn days_to_ymd(days: u64) -> (u64, u64, u64) {
    // Simplified calculation - not accounting for all edge cases
    let mut remaining_days = days;
    let mut year = 1970u64;

    loop {
        let days_in_year = if is_leap_year(year) { 366 } else { 365 };
        if remaining_days < days_in_year {
            break;
        }
        remaining_days -= days_in_year;
        year += 1;
    }

    let days_in_months: [u64; 12] = if is_leap_year(year) {
        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    } else {
        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    };

    let mut month = 1u64;
    for days_in_month in days_in_months.iter() {
        if remaining_days < *days_in_month {
            break;
        }
        remaining_days -= days_in_month;
        month += 1;
    }

    (year, month, remaining_days + 1)
}

fn is_leap_year(year: u64) -> bool {
    year.is_multiple_of(4) && (!year.is_multiple_of(100) || year.is_multiple_of(400))
}

/// Get current platform string
fn current_platform() -> String {
    let arch = std::env::consts::ARCH;
    let os = std::env::consts::OS;

    // Map to common platform strings
    let os_str = match os {
        "windows" => "pc-windows-msvc",
        "macos" => "apple-darwin",
        "linux" => "unknown-linux-gnu",
        _ => os,
    };

    format!("{}-{}", arch, os_str)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lockfile_new() {
        let lockfile = LockFile::new();
        assert_eq!(lockfile.version, LOCK_FILE_VERSION);
        assert!(lockfile.tools.is_empty());
    }

    #[test]
    fn test_lock_tool() {
        let mut lockfile = LockFile::new();
        let tool = LockedTool::new("3.11.11", "python-build-standalone")
            .with_resolved_from("3.11")
            .with_ecosystem(Ecosystem::Python);

        lockfile.lock_tool("python", tool);

        assert!(lockfile.is_locked("python"));
        let locked = lockfile.get_tool("python").unwrap();
        assert_eq!(locked.version, "3.11.11");
        assert_eq!(locked.resolved_from, "3.11");
    }

    #[test]
    fn test_lockfile_serialize() {
        let mut lockfile = LockFile::new();
        lockfile.lock_tool(
            "python",
            LockedTool::new("3.11.11", "python-build-standalone").with_resolved_from("3.11"),
        );
        lockfile.lock_tool(
            "node",
            LockedTool::new("20.18.0", "nodejs.org").with_resolved_from("20"),
        );

        let content = lockfile.to_string().unwrap();
        assert!(content.contains("vx.lock"));
        assert!(content.contains("[tools.python]"));
        assert!(content.contains("version = \"3.11.11\""));
    }

    #[test]
    fn test_lockfile_parse() {
        let content = r#"
version = 1

[metadata]
generated_at = "2025-12-30T10:00:00Z"
vx_version = "0.7.0"
platform = "x86_64-pc-windows-msvc"

[tools.python]
version = "3.11.11"
source = "python-build-standalone"
resolved_from = "3.11"

[tools.node]
version = "20.18.0"
source = "nodejs.org"
resolved_from = "20"
"#;

        let lockfile = LockFile::parse(content).unwrap();
        assert_eq!(lockfile.version, 1);
        assert_eq!(lockfile.tools.len(), 2);
        assert_eq!(lockfile.get_tool("python").unwrap().version, "3.11.11");
        assert_eq!(lockfile.get_tool("node").unwrap().version, "20.18.0");
    }

    #[test]
    fn test_check_consistency() {
        let mut lockfile = LockFile::new();
        lockfile.lock_tool(
            "python",
            LockedTool::new("3.11.11", "python-build-standalone").with_resolved_from("3.11"),
        );
        lockfile.lock_tool(
            "node",
            LockedTool::new("20.18.0", "nodejs.org").with_resolved_from("20"),
        );

        let mut config = HashMap::new();
        config.insert("python".to_string(), "3.11".to_string());
        config.insert("rust".to_string(), "stable".to_string());

        let inconsistencies = lockfile.check_consistency(&config);
        assert_eq!(inconsistencies.len(), 2); // rust missing, node extra
    }

    #[test]
    fn test_locked_tool_from_resolved() {
        let resolved = ResolvedVersion::new(Version::new(3, 11, 11), "3.11")
            .with_source("python-build-standalone");

        let locked = LockedTool::from(&resolved);
        assert_eq!(locked.version, "3.11.11");
        assert_eq!(locked.resolved_from, "3.11");
        assert_eq!(locked.source, "python-build-standalone");
    }
}

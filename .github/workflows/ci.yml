name: CI

# Continuous Integration for PR validation and main branch verification
# - Code quality checks (formatting, clippy, documentation)
# - Comprehensive testing across platforms and Rust versions
# - Security auditing and MSRV verification
# - Build verification for key platforms
# - Release-plz configuration validation (PR only)

on:
  pull_request:
    branches: [main]
  push:
    branches: [main, develop]

permissions:
  contents: read
  actions: read
  security-events: write

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  # Code quality checks - formatting, clippy, and documentation
  code_quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-quality-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-quality-
            ${{ runner.os }}-cargo-

      - name: Check formatting
        run: cargo fmt --all -- --check

      - name: Run clippy
        run: |
          echo "üîç Running Clippy for code quality checks..."
          # Run clippy with standard warnings, but allow pedantic lints
          cargo clippy --all-targets --all-features -- -D warnings -A clippy::pedantic -A clippy::nursery

      - name: Check documentation
        run: cargo doc --all-features --no-deps --document-private-items
        env:
          RUSTDOCFLAGS: "-D warnings"

  # Comprehensive testing across platforms
  test:
    name: Test - ${{ matrix.platform.name }}
    runs-on: ${{ matrix.platform.os }}
    strategy:
      matrix:
        platform:
          # Native compilation platforms - full build and test
          - name: Linux-x86_64
            os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            rust: stable
            cross_compile: false
          - name: Linux-x86_64-beta
            os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            rust: beta
            cross_compile: false
          - name: Windows-x86_64
            os: windows-latest
            target: x86_64-pc-windows-msvc
            rust: stable
            cross_compile: false
          - name: macOS-x86_64
            os: macos-latest
            target: x86_64-apple-darwin
            rust: stable
            cross_compile: false
          # ARM64 Linux using Docker for native compilation
          - name: Linux-ARM64
            os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            rust: stable
            cross_compile: false
            use_docker: true
          - name: Linux-musl
            os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            rust: stable
            cross_compile: false
            use_docker: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Set up QEMU for ARM64 emulation
      - name: Set up QEMU
        if: matrix.platform.use_docker == true
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      # Set up Docker Buildx for multi-platform builds
      - name: Set up Docker Buildx
        if: matrix.platform.use_docker == true
        uses: docker/setup-buildx-action@v3

      # Build and test in Docker container (ARM64 or musl)
      - name: Build and test in Docker container
        if: matrix.platform.use_docker == true
        run: |
          # Determine platform and image based on target
          if [[ "${{ matrix.platform.target }}" == "aarch64-unknown-linux-gnu" ]]; then
            PLATFORM="linux/arm64"
            IMAGE="rust:1.82-slim"
            DEPS="pkg-config libssl-dev"
            TARGET_FLAG=""
          elif [[ "${{ matrix.platform.target }}" == "x86_64-unknown-linux-musl" ]]; then
            PLATFORM="linux/amd64"
            IMAGE="rust:1.82-alpine"
            DEPS="pkgconf-dev openssl-dev musl-dev"
            TARGET_FLAG="--target x86_64-unknown-linux-musl"
          else
            echo "Unsupported Docker target: ${{ matrix.platform.target }}"
            exit 1
          fi

          docker run --rm \
            --platform $PLATFORM \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace \
            $IMAGE \
            sh -c "
              if command -v apk >/dev/null 2>&1; then
                apk add --no-cache $DEPS
              else
                apt-get update && apt-get install -y $DEPS
              fi && \
              cargo build --release --all-features $TARGET_FLAG && \
              cargo test --all-features $TARGET_FLAG
            "

      # Install musl tools for musl target
      - name: Install musl tools
        if: matrix.platform.target == 'x86_64-unknown-linux-musl' && matrix.platform.use_docker != true
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools

      # For native compilation (non-Docker): run both build and test
      - name: Run tests and build (native)
        if: matrix.platform.cross_compile == false && matrix.platform.use_docker != true
        uses: houseabsolute/actions-rust-cross@v1
        with:
          command: both
          target: ${{ matrix.platform.target }}
          toolchain: ${{ matrix.platform.rust }}
          args: "--locked --all-features"
          use-rust-cache: true

  # Build verification for key platforms only (not all targets)
  # This ensures the code compiles but doesn't upload artifacts
  # Each platform builds its native target to avoid cross-compilation issues
  build-check:
    name: Build Check
    strategy:
      matrix:
        include:
          # Native builds only - no cross-compilation
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
          - os: macos-latest
            target: x86_64-apple-darwin
          - os: windows-latest
            target: x86_64-pc-windows-msvc
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-build-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-build-
            ${{ runner.os }}-cargo-

      - name: Build verification (native target)
        run: cargo build --release

      # No artifact upload - this is just verification

  # Security audit using rustsec database
  security_audit:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run security audit
        uses: rustsec/audit-check@v2.0.0
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

  # Check minimum supported Rust version
  msrv:
    name: MSRV
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-msrv-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-msrv-
            ${{ runner.os }}-cargo-

      - name: Check MSRV
        run: cargo check --all-features

  # Validate release-plz configuration (PR only)
  release_plz_config_check:
    name: Release-plz Config Validation
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # For PR events, checkout the PR head commit (supports fork PRs)
          ref: ${{ github.event.pull_request.head.sha || github.head_ref }}

      - name: Debug PR information
        run: |
          echo "üîç Debugging PR and checkout information..."
          echo "Event name: ${{ github.event_name }}"
          echo "Repository: ${{ github.repository }}"
          echo "Head ref: ${{ github.head_ref }}"
          echo "Base ref: ${{ github.base_ref }}"
          echo "PR number: ${{ github.event.number }}"
          echo "PR head SHA: ${{ github.event.pull_request.head.sha }}"
          echo "PR head ref: ${{ github.event.pull_request.head.ref }}"
          echo "PR head repo: ${{ github.event.pull_request.head.repo.full_name }}"
          echo "PR base repo: ${{ github.event.pull_request.base.repo.full_name }}"
          echo "Current SHA: ${{ github.sha }}"
          echo ""
          echo "üìÅ Current working directory contents:"
          ls -la
          echo ""
          echo "üåø Git branch information:"
          git branch -a || echo "Git branch command failed"
          echo ""
          echo "üìù Git log (last 3 commits):"
          git log --oneline -3 || echo "Git log command failed"

      - name: Validate GitHub Token
        run: |
          echo "üîê Validating GitHub Token configuration..."
          echo ""
          # Check if RELEASE_PLZ_TOKEN is available (we can't access the actual value for security)
          if [ -n "${{ secrets.RELEASE_PLZ_TOKEN }}" ]; then
            echo "‚úÖ RELEASE_PLZ_TOKEN is configured"
            TOKEN_SOURCE="RELEASE_PLZ_TOKEN"
          else
            echo "‚ö†Ô∏è RELEASE_PLZ_TOKEN not found, will use GITHUB_TOKEN"
            TOKEN_SOURCE="GITHUB_TOKEN"
          fi

          # Test token format validation logic (using GITHUB_TOKEN as it's always available)
          TEST_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          # Basic token format validation
          if [[ "$TEST_TOKEN" =~ ^(ghp_|gho_|ghu_|ghs_|ghr_|github_pat_) ]]; then
            echo "‚úÖ Token format validation logic works correctly"
          else
            echo "‚ùå Token format validation failed - this may indicate an issue"
            exit 1
          fi

          # Test API connectivity with GITHUB_TOKEN
          echo "üåê Testing GitHub API connectivity..."
          curl -s -H "Authorization: Bearer $TEST_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/user > /dev/null || {
            echo "‚ùå GitHub API connectivity test failed"
            exit 1
          }
          echo "‚úÖ GitHub API connectivity test passed"
          echo "üéØ Token validation will use: $TOKEN_SOURCE"

      - name: Validate release-plz configuration file
        run: |
          echo "üîß Validating release-plz configuration..."
          echo ""
          # Check if config file exists
          if [ -f "release-plz.toml" ]; then
            echo "‚úÖ release-plz.toml found"
          else
            echo "‚ùå release-plz.toml not found"
            exit 1
          fi

          # Validate TOML syntax
          echo "üß™ Checking TOML syntax..."
          if command -v toml-cli &> /dev/null; then
            toml-cli get release-plz.toml . > /dev/null || {
              echo "‚ùå Invalid TOML syntax in release-plz.toml"
              exit 1
            }
          else
            # Basic syntax check using Python (available in GitHub runners)
            python3 -c "
          import tomllib
          try:
              with open('release-plz.toml', 'rb') as f:
                  tomllib.load(f)
              print('‚úÖ TOML syntax is valid')
          except Exception as e:
              print(f'‚ùå TOML syntax error: {e}')
              exit(1)
          " || exit 1
          fi

          echo ""
          echo "‚úÖ Release-plz configuration validation completed!"
          echo "üìù Configuration file exists and has valid TOML syntax."
          echo "üéØ The workflow should work correctly when merged to main."

  # Verify package build readiness to catch dependency issues early
  package_verification:
    name: Package Build Verification
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-publish-sim-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-publish-sim-
            ${{ runner.os }}-cargo-

      - name: Verify package build readiness
        run: |
          echo "üîç Verifying package build readiness..."
          echo ""

          # Test building each crate individually to ensure they compile correctly
          # This verifies dependency resolution without requiring crates.io publishing
          CRATES_TO_TEST=(
            # Layer 1: Foundation (no internal deps)
            "vx-dependency"
            "vx-paths"
            "vx-version"
            # Layer 2: Config (needed by plugin)
            "vx-config"
            # Layer 3: Core utilities (depends on config)
            "vx-plugin"
            "vx-installer"
            "vx-download"
            # Layer 4: Core services
            "vx-core"
            "vx-benchmark"
            # Layer 5: Tool framework
            "vx-tool-standard"
            # Layer 6: Simple tools
            "vx-tool-npm"
            "vx-tool-uv"
            "vx-tool-python"
            "vx-tool-rust"
            "vx-tool-go"
            "vx-tool-bun"
            # Layer 7: Node ecosystem
            "vx-tool-node"
            "vx-tool-pnpm"
            "vx-tool-yarn"
            # Layer 8: Application
            "vx-cli"
            "vx"
          )

          for crate in "${CRATES_TO_TEST[@]}"; do
            echo "üî® Building crate: $crate"
            if cargo build -p "$crate" --release; then
              echo "‚úÖ $crate builds successfully"
            else
              echo "‚ùå $crate build failed"
              exit 1
            fi
            echo ""
          done

          echo "üéâ All crates build successfully!"
          echo "üí° Dependencies are correctly resolved and ready for publishing"

  # Code coverage reporting (only on PR)
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-coverage-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-coverage-
            ${{ runner.os }}-cargo-

      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
          fail_ci_if_error: false
          verbose: true
          flags: unittests
          name: codecov-umbrella

# RFC 0008: Universal Version Solver Design

> **Status**: Implementing
> **Author**: vx team
> **Created**: 2025-12-30
> **Target Version**: v0.7.0

## Summary

This RFC proposes implementing a universal version solver in the `vx-resolver` crate, inspired by [rez](https://rez.readthedocs.io/en/3.2.0/api/rez.solver.html), supporting:

1. **Partial version matching** - `3.11` → `3.11.11`
2. **Version constraint expressions** - `>=3.9,<3.12`
3. **Lock file mechanism** - `vx.lock` ensures reproducible environments
4. **Multi-ecosystem support** - Different version semantics for different languages

## Motivation

### Current Issues

1. **Inconsistent version resolution**
   ```bash
   # vx.toml configuration
   python = "3.11"

   # vx sync attempts to download
   # Error: cpython-3.11+20251217-... (missing patch version)
   # Expected: cpython-3.11.11+20251217-...
   ```

2. **Lack of lock file mechanism**
   - Versions generated by `vx init` may resolve to different versions during `vx setup`/`vx sync`
   - Inconsistent team environments
   - Non-reproducible CI/CD builds

3. **Limited version constraint expression**
   - Only supports exact versions or `latest`
   - Cannot express constraints like `>=3.9,<3.12`

4. **Duplicate version resolution in Providers**
   - `PythonRuntime.resolve_version()`
   - `NodeRuntime.resolve_version()`
   - Scattered logic, difficult to maintain

### Industry Comparison

| Tool | Version Resolution | Lock File | Constraint Expressions |
|------|-------------------|-----------|------------------------|
| **rez** | ✅ Complete Solver | ✅ resolved_packages | ✅ Rich syntax |
| **uv/pip** | ✅ PEP 440 | ✅ uv.lock | ✅ PEP 440 |
| **npm/yarn** | ✅ semver | ✅ package-lock.json | ✅ semver ranges |
| **cargo** | ✅ semver | ✅ Cargo.lock | ✅ semver |
| **mise** | ✅ Partial matching | ❌ | ⚠️ Limited |
| **vx (current)** | ⚠️ Basic | ❌ | ❌ |

## Design

### 1. Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                      vx-resolver                             │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────────┐    ┌─────────────────┐                 │
│  │  VersionSolver  │───▶│  SolverStatus   │                 │
│  └────────┬────────┘    └─────────────────┘                 │
│           │                                                  │
│           ▼                                                  │
│  ┌─────────────────┐    ┌─────────────────┐                 │
│  │ VersionRequest  │───▶│ ResolvedVersion │                 │
│  └────────┬────────┘    └─────────────────┘                 │
│           │                                                  │
│           ▼                                                  │
│  ┌─────────────────┐    ┌─────────────────┐                 │
│  │VersionStrategy  │───▶│   Ecosystem     │                 │
│  │  (per ecosystem)│    │  (Node/Python/  │                 │
│  └─────────────────┘    │   Go/Rust/...)  │                 │
│                         └─────────────────┘                 │
│                                                              │
│  ┌─────────────────┐    ┌─────────────────┐                 │
│  │   LockFile      │◀──▶│  vx.lock        │                 │
│  └─────────────────┘    └─────────────────┘                 │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 2. Core Types

```rust
// crates/vx-resolver/src/version/mod.rs

/// Version request - what the user specified in vx.toml
pub struct VersionRequest {
    /// Original version string (e.g., "3.11", ">=3.9,<3.12", "latest")
    pub raw: String,
    /// Parsed constraint
    pub constraint: VersionConstraint,
}

/// Version constraint types
pub enum VersionConstraint {
    /// Exact version: "3.11.11"
    Exact(Version),
    /// Partial version: "3.11" (matches latest 3.11.x)
    Partial { major: u32, minor: u32 },
    /// Major version only: "3" (matches latest 3.x.x)
    Major(u32),
    /// Latest stable version
    Latest,
    /// Latest prerelease version
    LatestPrerelease,
    /// Range constraints: ">=3.9,<3.12"
    Range(Vec<RangeConstraint>),
    /// Wildcard: "3.11.*"
    Wildcard { major: u32, minor: u32 },
    /// Caret constraint: "^1.2.3" (>=1.2.3, <2.0.0)
    Caret(Version),
    /// Tilde constraint: "~1.2.3" (>=1.2.3, <1.3.0)
    Tilde(Version),
}

/// Range operators
pub enum RangeOp {
    Eq,      // =
    Ne,      // !=
    Gt,      // >
    Ge,      // >=
    Lt,      // <
    Le,      // <=
    Tilde,   // ~= (compatible release)
    Caret,   // ^  (compatible with)
}

/// Resolved version with full metadata
pub struct ResolvedVersion {
    /// Full version number
    pub version: Version,
    /// Source (GitHub release, npm registry, etc.)
    pub source: String,
    /// Additional metadata
    pub metadata: HashMap<String, String>,
}

/// Solver status (inspired by rez)
pub enum SolverStatus {
    Pending,
    Solved,
    Failed,
    Cyclic,
    InProgress,
}
```

### 3. Version Strategy Trait

```rust
/// Version resolution strategy - each ecosystem can have its own implementation
pub trait VersionStrategy: Send + Sync {
    /// Ecosystem name
    fn ecosystem(&self) -> Ecosystem;

    /// Check if a version satisfies a constraint
    fn satisfies(&self, version: &Version, constraint: &VersionConstraint) -> bool;

    /// Select the best match from available versions
    fn select_best_match(
        &self,
        constraint: &VersionConstraint,
        available: &[VersionInfo],
    ) -> Option<ResolvedVersion>;

    /// Compare two versions
    fn compare(&self, a: &Version, b: &Version) -> std::cmp::Ordering;

    /// Normalize a version string
    fn normalize(&self, version: &str) -> String;
}

/// Default semver strategy (works for most tools)
pub struct SemverStrategy;

/// Python PEP 440 strategy
pub struct Pep440Strategy;

/// Go version strategy (handles go1.22 format)
pub struct GoVersionStrategy;
```

### 4. Version Solver

```rust
/// Version solver
pub struct VersionSolver {
    strategies: HashMap<Ecosystem, Box<dyn VersionStrategy>>,
    config: SolverConfig,
}

impl VersionSolver {
    /// Resolve a single tool's version
    pub fn resolve(
        &self,
        tool: &str,
        request: &VersionRequest,
        available: &[VersionInfo],
        ecosystem: &Ecosystem,
    ) -> Result<ResolvedVersion, SolverError>;

    /// Resolve multiple tools at once
    pub fn resolve_all(
        &self,
        requests: &[(String, VersionRequest, Ecosystem, Vec<VersionInfo>)],
    ) -> SolverResult;

    /// Check if a version satisfies a constraint
    pub fn version_satisfies(
        &self,
        version_str: &str,
        constraint_str: &str,
        ecosystem: &Ecosystem,
    ) -> bool;
}
```

## Usage Examples

```rust
use vx_resolver::{VersionSolver, VersionRequest, Ecosystem};
use vx_runtime::VersionInfo;

// Create solver
let solver = VersionSolver::new();

// Resolve partial version
let available = vec![
    VersionInfo::new("3.10.0"),
    VersionInfo::new("3.11.0"),
    VersionInfo::new("3.11.11"),
    VersionInfo::new("3.12.0"),
];
let request = VersionRequest::parse("3.11");
let resolved = solver.resolve("python", &request, &available, &Ecosystem::Python)?;
assert_eq!(resolved.version_string(), "3.11.11");

// Resolve range constraint
let request = VersionRequest::parse(">=3.9,<3.12");
let resolved = solver.resolve("python", &request, &available, &Ecosystem::Python)?;
assert_eq!(resolved.version_string(), "3.11.11");

// Check version compatibility
assert!(solver.version_satisfies("1.2.3", "^1.0.0", &Ecosystem::Node));
assert!(!solver.version_satisfies("2.0.0", "^1.0.0", &Ecosystem::Node));
```

## Backward Compatibility

### Compatibility Strategy

1. **Behavior without lock file**
   - If no `vx.lock` exists, behavior is consistent with current implementation
   - First run of `vx sync` automatically generates `vx.lock`

2. **Version string compatibility**
   - `"3.11"` - Continues to work, parsed as partial version
   - `"latest"` - Continues to work
   - `"3.11.11"` - Continues to work, exact version

3. **Progressive enhancement**
   - New constraint syntax (`>=`, `<`, `^`, `~`) is optional
   - Projects not using new syntax are unaffected

## Implementation Plan

### Phase 1: Core Version Resolution (v0.7.0) ✅ Completed

- [x] `VersionRequest` and `VersionConstraint` types
- [x] `SemverStrategy` default implementation
- [x] `VersionSolver` basic implementation
- [x] Partial version matching (`3.11` → `3.11.11`)
- [x] Range constraints (`>=`, `<`, `!=`)
- [x] Compatible versions (`^`, `~`)
- [x] Wildcards (`*`)
- [x] `Pep440Strategy` (Python)
- [x] `GoVersionStrategy` (Go)
- [x] Unit tests
- [ ] Update `PythonRuntime` to use new resolver

### Phase 2: Lock File Mechanism (v0.7.1) ✅ Completed

- [x] `LockFile` type and parsing
- [x] `vx lock` command
- [x] `vx sync` lock file integration
- [x] `vx check` consistency check
- [x] Automatic lock file updates

### Phase 3: Multi-ecosystem Strategies (v0.8.0) ✅ Completed

- [x] `Pep440Strategy` (Python) - Completed in Phase 1
- [x] `NodeSemverStrategy` (Node.js) - Uses SemverStrategy
- [x] `GoVersionStrategy` (Go) - Completed in Phase 1
- [x] Provider integration
- [ ] Documentation updates

### Phase 4: Advanced Constraints (v0.9.0)

- [x] Range constraints (`>=`, `<`, `!=`) - Completed in Phase 1
- [x] Compatible versions (`^`, `~`) - Completed in Phase 1
- [x] Wildcards (`*`) - Completed in Phase 1
- [ ] Constraint conflict detection

## Current Design Limitations and Future Improvements

### 1. Missing Lock File Integrity Verification

**Problem**: The lock file supports a `checksum` field, but it's not actually verified during download/install.

**Risks**:
- Supply chain attacks: Malicious replacement of binaries at download sources
- Download corruption: Incomplete files due to network issues

**Proposed Solution**:
```rust
// Phase 5: Integrity Verification
pub struct IntegrityVerifier {
    /// Verify downloaded file matches checksum in lock file
    pub async fn verify(&self, path: &Path, expected: &str) -> Result<bool>;

    /// Compute SHA256 checksum of a file
    pub fn compute_checksum(&self, path: &Path) -> Result<String>;
}
```

### 2. Cross-Platform Lock File Compatibility

**Problem**: The lock file records `platform` info, but different platforms may have different versions available.

**Scenario**:
- Windows developer generates `vx.lock`
- Linux CI environment uses it, but some tools may not have corresponding versions

**Proposed Solution**:
```toml
# vx.lock multi-platform support
[tools.python]
version = "3.11.11"
resolved_from = "3.11"

[tools.python.platforms]
"x86_64-pc-windows-msvc" = { checksum = "sha256:abc..." }
"x86_64-unknown-linux-gnu" = { checksum = "sha256:def..." }
"aarch64-apple-darwin" = { checksum = "sha256:ghi..." }
```

### 3. Lock File Version Migration

**Problem**: How to handle old lock file versions when `vx.lock` format is upgraded?

**Proposed Solution**:
```rust
impl LockFile {
    /// Migrate old lock file versions to current version
    pub fn migrate(content: &str) -> Result<Self> {
        let version = detect_version(content)?;
        match version {
            1 => migrate_v1_to_v2(content),
            2 => Self::parse(content),
            _ => Err(LockFileError::UnsupportedVersion(version)),
        }
    }
}
```

### 4. Dependency Resolution Order

**Problem**: When tools have dependencies (e.g., `npm` depends on `node`), current implementation doesn't guarantee install order.

**Scenario**:
```toml
[tools]
npm = "latest"    # requires node
node = "20"
```

**Proposed Solution**:
```rust
/// Topological sort dependency graph to ensure dependencies are installed first
pub fn resolve_install_order(
    tools: &HashMap<String, LockedTool>,
    dependencies: &HashMap<String, Vec<String>>,
) -> Vec<String>;
```

### 5. Offline Mode Support

**Problem**: Current design assumes network availability, cannot work in offline environments.

**Proposed Solution**:
```rust
pub struct OfflineCache {
    /// Pre-download all tools to local cache
    pub async fn prefetch(&self, lockfile: &LockFile) -> Result<()>;

    /// Install from cache without network access
    pub async fn install_from_cache(&self, tool: &str) -> Result<()>;
}
```

### 6. Lock File Conflict Resolution

**Problem**: During team collaboration, `vx.lock` may have merge conflicts.

**Proposed Solution**:
```bash
# New command: Smart merge lock files
vx lock --merge base.lock ours.lock theirs.lock

# Or: Re-resolve all versions
vx lock --force
```

### 7. Security Updates for Version Ranges

**Problem**: When using range constraints (e.g., `>=3.9,<3.12`), how to handle security updates?

**Scenario**:
- Locked `python = 3.11.10`
- `3.11.11` released with security fix
- User needs to manually run `vx lock --update python`

**Proposed Solution**:
```bash
# New command: Only update patch versions (security updates)
vx lock --update-patch

# Or: Check for available security updates
vx outdated --security
```

### 8. Tool Aliases and Virtual Tools

**Problem**: Some tools have multiple names (e.g., `python3` → `python`), currently not supported.

**Proposed Solution**:
```toml
# vx.toml
[tools]
python = "3.11"

[aliases]
python3 = "python"
py = "python"
```

### 9. Environment Variable Overrides

**Problem**: CI/CD may need to temporarily override lock file versions.

**Proposed Solution**:
```bash
# Environment variable override
VX_PYTHON_VERSION=3.12 vx sync

# Or command line argument
vx sync --override python=3.12
```

### 10. Audit and Security Scanning

**Problem**: Cannot check if locked versions have known vulnerabilities.

**Proposed Solution**:
```bash
# New command: Security audit
vx audit

# Output
⚠ python 3.11.10 has known vulnerabilities:
  - CVE-2024-XXXX (High): ...
  Recommendation: Update to 3.11.11+
```

## Implementation Priority Recommendations

| Priority | Improvement | Reason |
|----------|-------------|--------|
| P0 | Integrity verification | Security critical |
| P1 | Dependency resolution order | Affects correctness |
| P1 | Cross-platform lock file | Required for team collaboration |
| P2 | Offline mode | Common in CI/CD scenarios |
| P2 | Security updates | Security critical |
| P3 | Lock file migration | Long-term maintenance |
| P3 | Alias support | User experience |
| P4 | Audit functionality | Enterprise requirement |

## References

- [rez solver API](https://rez.readthedocs.io/en/3.2.0/api/rez.solver.html)
- [PEP 440 - Version Identification](https://peps.python.org/pep-0440/)
- [Semantic Versioning 2.0.0](https://semver.org/)
- [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver)
- [Cargo resolver](https://doc.rust-lang.org/cargo/reference/resolver.html)
- [uv resolver](https://docs.astral.sh/uv/concepts/resolution/)

## Changelog

| Date | Version | Changes |
|------|---------|---------|
| 2025-12-30 | Draft | Initial draft |
| 2025-12-30 | v0.1.0 | Phase 1 core version resolution implemented |
| 2025-12-31 | v0.2.0 | Phase 2 lock file mechanism implemented |
| 2025-12-31 | v0.3.0 | Phase 2/3 completed: vx sync lock file integration, automatic lock file updates, Provider integration |
| 2025-12-31 | v0.4.0 | Added design limitations analysis and future improvements |

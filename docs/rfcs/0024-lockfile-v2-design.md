# vx.lock v2 设计方案

## 当前问题

1. **vx.lock 只记录版本号**，不包含下载 URL
2. **无法精准下载**：每次都需要重新计算下载 URL
3. **不支持离线模式**：bundle 模式下应该直接使用已解析的 URL
4. **缺少多平台支持**：不同平台有不同的下载 URL

## 目标

参考 uv.lock 和其他包管理器的最佳实践，增强 vx.lock 以支持：

1. ✅ 精确的下载 URL
2. ✅ 文件校验（SHA256）
3. ✅ 多平台支持
4. ✅ 完整的依赖信息
5. ✅ 可重现性

## 新的 vx.lock 格式

```toml
# vx.lock - Auto-generated, do not edit manually
# Generated by vx 0.7.0

version = 2  # 升级到 v2

[metadata]
generated_at = "2025-12-30T10:00:00Z"
vx_version = "0.7.0"
platform = "x86_64-pc-windows-msvc"
platforms = ["x86_64-pc-windows-msvc", "aarch64-apple-darwin"]

[tools.python]
version = "3.11.13"
source = "python-build-standalone"
resolved_from = "3.11"
ecosystem = "Python"
checksum = "sha256:abc123..."
download_url = "https://github.com/astral-sh/python-build-standalone/releases/download/20250610/cpython-3.11.13+20250610-x86_64-pc-windows-msvc-install_only_stripped.tar.gz"

[tools.python.platform_urls]
"x86_64-pc-windows-msvc" = "https://github.com/astral-sh/python-build-standalone/releases/download/20250610/cpython-3.11.13+20250610-x86_64-pc-windows-msvc-install_only_stripped.tar.gz"
"aarch64-apple-darwin" = "https://github.com/astral-sh/python-build-standalone/releases/download/20250610/cpython-3.11.13+20250610-aarch64-apple-darwin-install_only_stripped.tar.gz"

[tools.node]
version = "20.0.0"
source = "nodejs.org"
resolved_from = "20"
ecosystem = "Node"
checksum = "sha256:def456..."
download_url = "https://nodejs.org/dist/v20.0.0/node-v20.0.0-win-x64.zip"

[tools.node.platform_urls]
"x86_64-pc-windows-msvc" = "https://nodejs.org/dist/v20.0.0/node-v20.0.0-win-x64.zip"
"aarch64-apple-darwin" = "https://nodejs.org/dist/v20.0.0/node-v20.0.0-darwin-arm64.tar.gz"

[dependencies]
# npm, npx 依赖 node
npm = ["node"]
npx = ["node"]
```

## 数据结构变更

### LockedTool 新增字段

```rust
pub struct LockedTool {
    /// Resolved version string (e.g., "3.11.11")
    pub version: String,
    
    /// Source (e.g., "python-build-standalone", "nodejs.org")
    pub source: String,
    
    /// Original version request (e.g., "3.11", "latest")
    pub resolved_from: String,
    
    /// Ecosystem of the tool
    #[serde(default)]
    pub ecosystem: Ecosystem,
    
    /// SHA256 checksum of downloaded artifact
    #[serde(skip_serializing_if = "Option::is_none")]
    pub checksum: Option<String>,
    
    /// ✅ NEW: Download URL for the current platform
    #[serde(skip_serializing_if = "Option::is_none")]
    pub download_url: Option<String>,
    
    /// ✅ NEW: Platform-specific download URLs (platform -> URL)
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub platform_urls: HashMap<String, String>,
    
    /// Additional metadata
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub metadata: HashMap<String, String>,
}
```

### 辅助方法

```rust
impl LockedTool {
    /// Get download URL for a specific platform
    pub fn download_url_for_platform(&self, platform: &str) -> Option<&String> {
        // 1. Try platform-specific URL
        if let Some(url) = self.platform_urls.get(platform) {
            return Some(url);
        }
        // 2. Fall back to current platform URL
        self.download_url.as_ref()
    }
    
    /// Set download URL for the current platform
    pub fn with_download_url(mut self, url: impl Into<String>) -> Self {
        self.download_url = Some(url.into());
        self
    }
    
    /// Add platform-specific download URL
    pub fn with_platform_url(mut self, platform: impl Into<String>, url: impl Into<String>) -> Self {
        self.platform_urls.insert(platform.into(), url.into());
        self
    }
}
```

## vx lock 命令的变更

在 `resolve_tool_version` 中获取下载 URL：

```rust
async fn resolve_tool_version(
    registry: &ProviderRegistry,
    ctx: &RuntimeContext,
    solver: &VersionSolver,
    tool_name: &str,
    version_str: &str,
) -> Result<LockedTool> {
    // ... existing code ...
    
    // Resolve version
    let resolved = solver
        .resolve(tool_name, &request, &versions, &ecosystem)
        .map_err(|e| anyhow::anyhow!("{}", e))?;
    
    // ✅ NEW: Get download URL for current platform
    let platform = vx_runtime::Platform::current();
    let download_url = runtime
        .download_url(&resolved.version.to_string(), &platform)
        .await
        .ok()
        .flatten();
    
    // ✅ NEW: Get download URLs for all supported platforms (optional)
    let mut platform_urls = HashMap::new();
    for target_platform in get_all_target_platforms() {
        if let Some(url) = runtime
            .download_url(&resolved.version.to_string(), &target_platform)
            .await
            .ok()
            .flatten()
        {
            platform_urls.insert(target_platform.to_string(), url);
        }
    }
    
    // Create locked tool entry
    let mut locked = LockedTool::new(resolved.version.to_string(), resolved.source.clone())
        .with_resolved_from(version_str)
        .with_ecosystem(ecosystem)
        .with_download_url(download_url.unwrap_or_default());
    
    // Add platform-specific URLs
    for (platform, url) in platform_urls {
        locked = locked.with_platform_url(platform, url);
    }
    
    // Copy metadata
    for (key, value) in &resolved.metadata {
        locked = locked.with_metadata(key, value);
    }
    
    Ok(locked)
}
```

## vx install/sync 命令的变更

优先使用 vx.lock 中的下载 URL：

```rust
async fn install_tool(name: &str, version: &str) -> (bool, Option<String>) {
    // ... existing code to check if already installed ...
    
    // ✅ Check if we have a lock file with download URL
    if let Some(lockfile) = load_lock_file() {
        if let Some(locked) = lockfile.get_tool(name) {
            if locked.version == version {
                if let Some(url) = locked.download_url_for_platform(&current_platform()) {
                    // Use lock file URL
                    return download_and_install(name, version, &url).await;
                }
            }
        }
    }
    
    // Fall back to resolving download URL from provider
    let url = resolve_download_url_from_provider(name, version).await?;
    download_and_install(name, version, &url).await
}
```

## vx bundle 的改进

bundle manifest 已经支持多平台，可以直接复用 vx.lock 中的信息：

```rust
async fn create_bundle() -> Result<()> {
    let lockfile = LockFile::load("vx.lock")?;
    
    for (tool_name, locked) in &lockfile.tools {
        // Use lock file URLs for faster bundling
        for (platform, url) in &locked.platform_urls {
            let downloaded = download_artifact(url).await?;
            bundle.add(tool_name, &locked.version, platform, downloaded);
        }
    }
}
```

## 优势

1. **精准下载**：使用预先解析的 URL，避免每次重新计算
2. **离线支持**：vx.lock 包含所有必要信息，支持完全离线
3. **多平台支持**：不同平台的团队可以共享同一个 vx.lock
4. **可重现性**：相同配置 + 相同 vx.lock = 完全相同的环境
5. **性能提升**：避免重复的网络请求和版本解析

## 向后兼容

- vx.lock v1 (version = 1) 会自动迁移到 v2
- 缺少的字段（download_url, platform_urls）会在下次 `vx lock` 时自动补充

```rust
impl LockFile {
    pub fn load(path: &Path) -> Result<Self, LockFileError> {
        let mut lockfile = toml::from_str(&content)?;
        
        // Auto-migrate v1 to v2
        if lockfile.version < 2 {
            lockfile.migrate_to_v2();
        }
        
        Ok(lockfile)
    }
    
    fn migrate_to_v2(&mut self) {
        self.version = 2;
        // Fill in missing fields for existing tools
        for (name, tool) in &mut self.tools {
            if tool.download_url.is_none() && tool.platform_urls.is_empty() {
                // Mark for refresh
                tool.metadata.insert(
                    "_needs_refresh".to_string(),
                    "true".to_string()
                );
            }
        }
    }
}
```

## 实现优先级

1. ✅ 修改 `LockedTool` 结构，添加 `download_url` 和 `platform_urls`
2. ✅ 修改 `vx lock` 命令，在解析时获取下载 URL
3. ✅ 修改 `vx install/sync` 命令，优先使用锁文件中的 URL
4. ✅ 修改 `vx bundle` 命令，利用锁文件中的信息
5. ✅ 添加 v1 到 v2 的迁移逻辑
6. ✅ 更新文档和测试

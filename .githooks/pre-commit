#!/bin/bash
# VX Pre-commit Hook
# This hook runs comprehensive quality checks before each commit
#
# Features:
# - Automatic code formatting with cargo fmt --all
# - Comprehensive clippy checks with custom lints
# - unwrap() detection in production code
# - TODO/FIXME tracking
# - Hardcoded value detection
# - Optional quick testing of affected modules
#
# Configuration (set as environment variables):
# - VX_QUICK_TEST=true: Run quick tests on affected modules
# - VX_STRICT_MODE=true: Fail on any warnings
# - VX_AUTO_FIX=false: Disable automatic formatting
#
# Usage:
# - Normal commit: git commit -m "message"
# - Skip checks: git commit --no-verify -m "message"
# - With quick tests: VX_QUICK_TEST=true git commit -m "message"

set -e

echo "🔍 Running pre-commit quality checks..."

# Configuration variables (can be set as environment variables)
VX_QUICK_TEST=${VX_QUICK_TEST:-false}
VX_STRICT_MODE=${VX_STRICT_MODE:-false}
VX_AUTO_FIX=${VX_AUTO_FIX:-true}

# Show configuration
if [ "$VX_QUICK_TEST" = "true" ] || [ "$VX_STRICT_MODE" = "true" ] || [ "$VX_AUTO_FIX" = "false" ]; then
    echo "📋 Configuration:"
    [ "$VX_QUICK_TEST" = "true" ] && echo "  - Quick tests: enabled"
    [ "$VX_STRICT_MODE" = "true" ] && echo "  - Strict mode: enabled"
    [ "$VX_AUTO_FIX" = "false" ] && echo "  - Auto-fix: disabled"
    echo
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_error() {
    echo -e "${RED}❌ $1${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

# Get list of staged Rust files
STAGED_RS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.rs$' || true)

if [ -z "$STAGED_RS_FILES" ]; then
    print_info "No Rust files staged for commit"
    exit 0
fi

print_info "Checking $(echo "$STAGED_RS_FILES" | wc -l) staged Rust files..."

# 1. Check for unwrap() in production code
print_info "Checking for unwrap() in production code..."
UNWRAP_FILES=""
for file in $STAGED_RS_FILES; do
    if [[ ! "$file" =~ test ]] && [[ ! "$file" =~ /tests/ ]]; then
        if grep -q "\.unwrap()" "$file"; then
            UNWRAP_FILES="$UNWRAP_FILES $file"
        fi
    fi
done

if [ -n "$UNWRAP_FILES" ]; then
    print_error "Found unwrap() calls in production code:"
    for file in $UNWRAP_FILES; do
        echo "  $file"
        grep -n "\.unwrap()" "$file" | head -3 | sed 's/^/    /'
    done
    print_error "Please replace unwrap() with proper error handling"
    exit 1
else
    print_success "No unwrap() calls found in staged production code"
fi

# 2. Check for TODO/FIXME in new code
print_info "Checking for TODO/FIXME in new code..."
TODO_COUNT=0
for file in $STAGED_RS_FILES; do
    TODO_LINES=$(git diff --cached "$file" | grep "^+" | grep -E "TODO|FIXME|HACK|XXX" || true)
    if [ -n "$TODO_LINES" ]; then
        TODO_COUNT=$((TODO_COUNT + 1))
        if [ $TODO_COUNT -eq 1 ]; then
            print_warning "Found TODO/FIXME in new code:"
        fi
        echo "  $file:"
        echo "$TODO_LINES" | sed 's/^/    /'
    fi
done

if [ $TODO_COUNT -gt 0 ]; then
    print_warning "Consider addressing TODO/FIXME items before committing"
fi

# 3. Run cargo fmt --all for comprehensive formatting
print_info "Checking code formatting..."

# Check if formatting is needed
if ! cargo fmt --all -- --check 2>/dev/null; then
    print_warning "Code formatting issues detected"

    if [ "$VX_AUTO_FIX" = "true" ]; then
        # Auto-format all code
        print_info "Running cargo fmt --all to fix formatting..."
        if cargo fmt --all; then
            print_success "Code formatted successfully"

            # Re-stage any formatted files that were already staged
            for file in $STAGED_RS_FILES; do
                if git diff --name-only | grep -q "^$file$"; then
                    print_info "Re-staging formatted file: $file"
                    git add "$file"
                fi
            done

            print_success "Formatted files re-staged"
        else
            print_error "Failed to format code"
            exit 1
        fi
    else
        print_error "Code formatting issues found and auto-fix is disabled"
        print_info "Run 'cargo fmt --all' to fix formatting, or set VX_AUTO_FIX=true"
        exit 1
    fi
else
    print_success "Code formatting is correct"
fi

# 4. Run comprehensive clippy check
print_info "Running clippy checks..."
if command -v cargo >/dev/null 2>&1; then
    # Run clippy with comprehensive checks
    print_info "Running cargo clippy --all-targets --all-features..."

    # Capture clippy output
    CLIPPY_OUTPUT=$(cargo clippy --all-targets --all-features --message-format=short 2>&1)
    CLIPPY_EXIT_CODE=$?

    if [ $CLIPPY_EXIT_CODE -eq 0 ]; then
        print_success "Clippy checks passed"
    else
        print_error "Clippy found issues:"
        echo "$CLIPPY_OUTPUT" | head -20

        if echo "$CLIPPY_OUTPUT" | grep -q "warning:"; then
            print_warning "Found clippy warnings"

            if [ "$VX_STRICT_MODE" = "true" ]; then
                print_error "Strict mode enabled - commit aborted due to clippy warnings"
                print_info "Fix the warnings and try again, or disable strict mode"
                exit 1
            else
                read -p "Continue with commit despite warnings? (y/N): " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    print_error "Commit aborted due to clippy warnings"
                    print_info "Fix the warnings and try again, or use 'git commit --no-verify' to skip checks"
                    exit 1
                fi
            fi
        else
            print_error "Found clippy errors - commit aborted"
            print_info "Fix the errors and try again, or use 'git commit --no-verify' to skip checks"
            exit 1
        fi
    fi

    # Additional clippy checks for common issues
    print_info "Running additional clippy checks..."

    # Check for specific lints that are important for code quality
    EXTRA_CLIPPY_OUTPUT=$(cargo clippy --all-targets --all-features -- \
        -W clippy::unwrap_used \
        -W clippy::expect_used \
        -W clippy::panic \
        -W clippy::unimplemented \
        -W clippy::todo \
        -W clippy::unreachable \
        -W clippy::clone_on_ref_ptr \
        -W clippy::redundant_clone \
        2>&1 || true)

    if echo "$EXTRA_CLIPPY_OUTPUT" | grep -q "warning:"; then
        print_warning "Additional clippy checks found issues:"
        echo "$EXTRA_CLIPPY_OUTPUT" | grep "warning:" | head -10
        print_info "Consider addressing these for better code quality"
    fi

else
    print_warning "Cargo not found, skipping clippy check"
fi

# 5. Check for large additions
print_info "Checking for large additions..."
for file in $STAGED_RS_FILES; do
    ADDITIONS=$(git diff --cached --numstat "$file" | cut -f1)
    if [ -n "$ADDITIONS" ] && [ "$ADDITIONS" -gt 200 ]; then
        print_warning "Large addition in $file ($ADDITIONS lines)"
        print_info "Consider breaking this into smaller commits"
    fi
done

# 6. Check for hardcoded values in new code
print_info "Checking for hardcoded values in new code..."
HARDCODED_COUNT=0
for file in $STAGED_RS_FILES; do
    HARDCODED_LINES=$(git diff --cached "$file" | grep "^+" | grep -E "https://[^\"]*\.(com|org|dev|io)|localhost|127\.0\.0\.1" || true)
    if [ -n "$HARDCODED_LINES" ]; then
        HARDCODED_COUNT=$((HARDCODED_COUNT + 1))
        if [ $HARDCODED_COUNT -eq 1 ]; then
            print_warning "Found potential hardcoded values in new code:"
        fi
        echo "  $file:"
        echo "$HARDCODED_LINES" | sed 's/^/    /'
    fi
done

if [ $HARDCODED_COUNT -gt 0 ]; then
    print_warning "Consider moving hardcoded values to configuration"
fi

# 7. Run quick tests on affected modules (optional)
if [ "${VX_QUICK_TEST:-false}" = "true" ]; then
    print_info "Running quick tests on affected modules..."

    # Find affected crates based on staged files
    AFFECTED_CRATES=""
    for file in $STAGED_RS_FILES; do
        # Find the nearest Cargo.toml
        DIR=$(dirname "$file")
        while [ "$DIR" != "." ] && [ "$DIR" != "/" ]; do
            if [ -f "$DIR/Cargo.toml" ]; then
                CRATE_NAME=$(grep "^name = " "$DIR/Cargo.toml" | head -1 | sed 's/name = "\(.*\)"/\1/')
                if [ -n "$CRATE_NAME" ] && ! echo "$AFFECTED_CRATES" | grep -q "$CRATE_NAME"; then
                    AFFECTED_CRATES="$AFFECTED_CRATES $CRATE_NAME"
                fi
                break
            fi
            DIR=$(dirname "$DIR")
        done
    done

    if [ -n "$AFFECTED_CRATES" ]; then
        print_info "Running tests for affected crates:$AFFECTED_CRATES"
        for crate in $AFFECTED_CRATES; do
            if timeout 60s cargo test -p "$crate" --lib 2>/dev/null; then
                print_success "Tests passed for $crate"
            else
                print_warning "Tests failed or timed out for $crate (non-blocking)"
            fi
        done
    fi
fi

# 8. Final summary and commit message suggestions
print_success "Pre-commit checks completed successfully!"

# Suggest conventional commit format if not already used
COMMIT_MSG_FILE=".git/COMMIT_EDITMSG"
if [ -f "$COMMIT_MSG_FILE" ]; then
    COMMIT_MSG=$(head -1 "$COMMIT_MSG_FILE" 2>/dev/null || echo "")
    if [ -n "$COMMIT_MSG" ] && ! echo "$COMMIT_MSG" | grep -qE "^(feat|fix|docs|style|refactor|test|chore|ci|build)(\(.+\))?: "; then
        print_info "💡 Consider using conventional commit format:"
        print_info "   feat: add new feature"
        print_info "   fix: resolve bug"
        print_info "   refactor: improve code structure"
        print_info "   docs: update documentation"
    fi
fi

print_info "🚀 Proceeding with commit..."
print_info "💡 Tip: Set VX_QUICK_TEST=true to run quick tests on affected modules"

exit 0
